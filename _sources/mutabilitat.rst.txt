###########
Mutabilitat
###########

Amb el que portem de curs hem treballat bàsicament amb els següents tipus
de dades: ``int``, ``float``, ``bool``, ``str`` i ``tuple``.

Tots aquests tipus comparteixen una característica comuna: són
**inmutables**. És a dir, els valors d'aquests tipus no poden ser
modificats.

Python identifica cada valor amb un número intern que podem consultar amb
la funció ``id()``. Per exemple, considera:

.. code-block:: python

    >>> id(1)
    94703901475264
    >>> x = 1
    >>> id(x)
    94703901475264
    >>> y = x
    >>> id(y)
    94703901475264

*Nota*: els identificadors que et surtin a tu poden ser diferents dels
meus.

Fixa't com el valor ``1`` té el mateix identificador que les variables ``x``
i ``y``. Per Python, ``1``, ``x`` i ``y`` representen el mateix *objecte*
en memòria.

Què passa si intentem modificar un d'aquests valors?

.. code-block:: python

    >>> x = x + 1
    >>> id(x)
    94703901475296
    >>> id(2)
    94703901475296
    >>> id(y)
    94703901475264

En aquest cas ``x`` passa a fer referència al valor ``2``. Hem canviat
l'objecte al que apunta **però no** el valor de l'objecte apuntat. Fixa't
com ``id(x) == id(2)`` mentre que ``id(y)`` continua sent igual que
``id(1)``.

Això explica el que hem experimentat que passa quan el canvi el fem a una funció:

.. code-block:: python

    >>> def foo(p):
    ...     print('abans  ', id(p))
    ...     p = p + 1
    ...     print('després', id(p))
    ... 
    >>> q = 1
    >>> id(q)
    94703901475264
    >>> foo(q)
    abans   94703901475264
    després 94703901475296
    >>> q
    1

Fixa't que a ``foo()`` estem canviant el valor del paràmetre ``p``. Sent
més precisos, estem modificant l'objecte al que fa referència ``p``. Quan
fem la crida a ``foo()`` li passem ``q`` com a argument de manera que, en
iniciar la crida, ``p`` i ``q`` fan referència al mateix objecte. Quan
tornem de la crida, ``q`` no s'ha vist modificada i continúa fent
referència al mateix objecte que abans de la crida.

Això funciona igual amb la resta dels tipus que hem vist fins ara. Per
exemple:

.. code-block:: python

    def afegeix_a_str_una_X(text):
        print("abans id(text):   ", id(text), "text:   ", text)
        text += 'X'
        print("després id(text): ", id(text), "text:   ", text)
        return text

    nom = 'Ada'
    print("inici id(nom):    ", id(nom), "nom:    ", nom)
    nou_nom = afegeix_a_str_una_X(nom)
    print("final id(nom):    ", id(nom), "nom:    ", nom)
    print("id(nou_nom):      ", id(nou_nom), "nou_nom:", nou_nom)

El resultat d'executar el codi anterior és:

.. code-block:: none

    inici id(nom):     140564991359216 nom:     Ada
    abans id(text):    140564991359216 text:    Ada
    després id(text):  140564990645000 text:    AdaX
    final id(nom):     140564991359216 nom:     Ada
    id(nou_nom):       140564990645000 nou_nom: AdaX

Com pots veure, l'objecte ``Ada`` es manté després de la crida. És més,
``nom`` continúa referenciant-lo malgrat dins la funció, el paràmetre
corresponent ``text`` ha passat a referenciar un altre objecte.

Si repetim l'experiment amb les tuples, ens sortirà quelcom similar.

Hi ha, però, tipus de dades que **sí** són mutables. En aquest tema
coneixerem el tipus ``list``, una seqüència molt similar a les tuples però
que sí permet modificar els seus elements.

.. toctree::
    :maxdepth: 1
    :titlesonly:

    llistes.rst
    llistes_foreach.rst
    llistes_segments.rst
    llistes_i_moduls.rst
