########################
Les seqüències en Python
########################

El problema anterior presenta la dificultat de requerir guardar, en algun
lloc, les notes que anem rebent. El problema és que no coneixem encara cap
tipus de dades que ens permeti guardar una seqüència d'enters.

Python ens ofereix diferents tipus de dades per poder agrupar dades de
manera seqüencial. De moment, ens quedarem amb una d'elles: la
*tupla*.

Considera la següent interacció amb la consola de Python

.. code-block:: python
    :linenos:

    >>> nombres = (1, 2, 'tres')
    >>> type(nombres)
    <class 'tuple'>
    >>> nombres[0]
    1
    >>> len(nombres)
    3
    >>> for i in range(0, len(nombres), 1):
    ...     print(type(nombres[i]))
    ... 
    <class 'int'>
    <class 'int'>
    <class 'str'>

Fixa't com:

* a la línia 1 inicialitzem la variable ``nombres`` amb tres enters
  separats per coma i entre parèntesis ``(`` i ``)``.

* el tipus de ``nombres`` és ``tuple``

* hi podem accedir als diferents valors de ``nombres`` tot indexant-los
  entre claudàtors ``[`` i ``]`` com ho fèiem amb strings. De fet, fins i
  tot és vàlida la funció ``len()`` per saber quants elements en tenim!

* com els strings, les tuples són *inmutables*, és a dir, un cop creades,
  no podem canviar els valors que contenen.

* el codi anterior mostra que fins i tot podem tenir diferents tipus de
  dades a una tupla! En aquest cas, tots són enters menys el darrer.

.. important:: En aquest tema, novament, veurem restringit l'ús de les
               utilitats que ens ofereix Python per manegar seqüències.
               Tot sigui per millorar les nostres habilitats de
               desenvolupament, oi?

Considera el següent codi:

.. code-block:: python
    :linenos:

    def suma_nomes_enters_positius(nombres):
        """ Donada una seqüència de strings, aquesta funció suma els valors enters
            positius que conté, i retorna el resultat

            Nota: en cas que algun valor dins de nombres no sigui string, el
            resultat és indeterminat.

            >>> suma_nomes_enters_positius(('a', '1', '-2', '3', 'això no!', 'True'))
            4
        """
        suma = 0
        for i in range(0, len(nombres), 1):
            if nombres[i].isdigit():
                suma += int(nombres[i])
        return suma

Fixa't que:

* el recorregut de la seqüència és idèntic al recorregut d'un string. A la
  línia 12 fem que la variable de recorregut ``i`` vagi de 0 fins a la
  longitud de la seqüència (menys un, és clar)

* l'accés a un element de la seqüència és també idèntic al d'un string.
  Mira la línia 13 i intenta distingir-la de codi similar que has fet amb
  strings fins ara.

Encara un altre exemple, considera el següent codi:

.. code-block:: python
    :linenos:

    def separa_parells_i_senars(valors):
        """ Donada una tupla d'enters, retorna una tupla que conté els
            mateixos enters però primer apareixen els parells i després
            els senars.

            >>> separa_parells_i_senars((1, 2, 3, 4, 5, 6))
            (2, 4, 6, 1, 3, 5)
        """
        parells = tuple()
        senars = ()
        for i in range(0, len(valors), 1):
            actual = valors[i]
            if actual % 2 == 1:
                senars = senars + (actual, )
            else:
                parells += (actual, )
        resultat = parells + senars
        return resultat

Fixa't com:

* el codi fa servir dues variables de tipus tupla per anar emmagatzemant
  els valors.

* la tupla buida es defineix simplement escrivint ``()`` però també podem
  fer-ho amb ``tuple()``.

  En canvi, la tupla amb un sol element, cal definir-la amb una ``,``
  extra. Altrament, Python es pensa que és un valor entre parèntesis!

* de la manteixa manera que concatenàvem strings (amb l'operador ``+``)
  també ho fem amb les tuples.

* la crida al doctest conté doble parèntesis. Els externs corresponen als
  parèntesis per definir que venen els arguments de la funció; els interns
  serveixen per delimitar la tupla.

Exercici 14. ☞ Suma només enters parells positius
=================================================

Desenvolupa una funció que rebi una seqüència de strings i retorni el
resultat de sumar tots els nombres enters positius i parells que hi
apareguin.

Abans de posar-te a programar la solució, recorda els conceptes de TDD que
hem vist fins ara. Planteja't com sabràs si el que has codificat és
correcte. Defineix els casos *extrems* del problema (ex. una seqüència
buida d'entrada) i quina és la resposta que ha de donar la teva solució.

Pots escollir si vols usar *doctest* o bé *pytest* per composar les teves
proves. Fins i tot, si vols, tots dos! Però cal que incloguis al menys una
d'elles.

.. code-block:: python

    >>> suma_parells_positius(('a', '1', '2', '-2', '4', '5', 'sis'))
    6

Els criteris d'acceptació d'aquest exercici són:

* has de passar la prova automàtica ``test/test.sh``

* has d'incloure diferents casos de test

* has de passar els teus casos de test (!)

Exercici 15. ☞ Suma només enters
================================

Desenvolupa una funció que rebi una seqüència de strings i retorni el
resultat de sumar tots els nombres enters que hi apareguin.

Per descomptat, et toca definir els casos de test. T'ofereixo un de
referència.

.. code-block:: python

    >>> suma_enters(('a', '1', '2', '-2', '+4', '5', 'sis'))
    10


.. _exercici_filtra_enters_tupla:

Exercici 16. ☞ Filtra enters
============================

Desenvolupa una funció que rebi una seqüència de strings i retorni una
seqüència amb només els nombres enters que hi
apareguin.

.. code-block:: python

    >>> filtra_enters(('a', '1', '2', '-2', '+4', '5', 'sis'))
    (1, 2, -2, 4, 5)

Inclou els casos de test que consideris que ha de complir el teu codi per
poder-se considerar correcte.


Exercici 17. ☞ Fins un màxim
============================

Desenvolupa una funció que rebi una seqüència d'enters i un valor màxim.
La funció retornarà una nova seqüència que contindrà els primers elements
de la seqüència original de manera que la suma d'aquests sigui, com a
molt, el valor màxim indicat.

.. code-block:: python

    >>> fins_un_maxim((1, 1, 2, -2, 4, 2, 4), 7)
    (1, 1, 2, -2, 4)

    >>> fins_un_maxim((1, 1, 2, -2, 4, 2, 4), 9)
    (1, 1, 2, -2, 4, 2)

    >>> fins_un_maxim((12, 1, 2, -2, 4, 2, 4), 9)
    ()

