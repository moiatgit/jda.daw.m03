#################
Control de bucles
#################

En aquesta secció, aprendrem a tenir més control sobre els bucles.

No vull arribar al final!
=========================

Segurament t'has trobat ja més d'un cop amb la situació de voler finalitzar un bucle abans d'arribar
al final, oi?

Per exemple, si volem desenvolupar una funció que retorni cert quan una lletra es troba dins d'una
frase, el codi amb ``for`` vindria a ser quelcom similar a:

.. code-block:: python
    :linenos:

    def text_conte_caracter(text, caracter):
        """ retorna True quan text conté al menys una ocurrència de caracter, False altrament.

            Espera que:
            - text i caracter siguin de tipus str
            - len(caracter) == 1

            >>> text_conte_caracter('Python is wonderful', 'z')
            False
            >>> text_conte_caracter('Python is wonderful', 'y')
            True
            >>> text_conte_caracter('Python is an interpreted high-level programming language for general-purpose programming. Created by Guido van Rossum and first released in 1991, Python has a design philosophy that emphasizes code readability, notably using significant whitespace. It provides constructs that enable clear programming on both small and large scales.', 'y')
            True
        """
        trobat = False
        for i in range(0, len(text), 1):
            if not trobat and text[i] == caracter:
                trobat = True
        return trobat

En el primer doctest, ``text_conte_caracter()`` ha d'arribar fins al final del text per tenir clar
que aquest no conté la lletra ``z``.
En el segon doctest, la funció ha d'arribar també fins al final, malgrat a la segona iteració ja
sap que ha de retornar ``True``.
En el tercer doctest, la funció també s'ha d'esperar fins el final del text. La diferència és que
ara el temps d'espera és molt més llarg!

.. sidebar:: No oblidis la documentació de les teves funcions!

    La funció ``text_conte_caracter()`` apareixerà en diferents versions. Per brevetat, li trec els
    comentaris. Amb tot, recorda que **tu** no ho pots fer sense una raó tan bona com aquesta!

Sabem resoldre aquest tipus de problemes fent servir un bucle condicional (el ``while``), per
exemple:

.. code-block:: python
    :linenos:

    def text_conte_caracter(text, caracter):
        trobat = False
        i = 0
        while not trobat and i < len(text):
            if text[i] == caracter:
                trobat = True
            i += 1
        return trobat

En aquesta versió, no importa la longitud del text. En el moment que trobem la lletra cercada,
finalitza el bucle.

Ep. Que això és una funció!
===========================

Donat que estem en una funció, disposem d'una possibilitat de finalitzar el bucle sense necessitat
d'arribar al final: fent servir ``return``

.. code-block:: python
    :linenos:

    def text_conte_caracter(text, caracter):
        for i in range(0, len(text), 1):
            if text[i] == caracter:
                return True
        return False

Fixat com, simplement en trobar el caràcter en qüestió, ja sabem el resultat de la funció i el podem
retornar directament sense esperar el final.

Trenquem el bucle
=================

No sempre podem retornar dins d'un bucle. Per exemple, podria passar que ens calgués realitzar algun
càlcul més després d'haver trobat el caràcter cercat.

Aquest tipus de problemes és molt típic. Tant, que la majoria dels llenguatges imperatius
ofereixen algun tipus de mecanisme per a afegir-hi control.

Considera la nova versió del problema anterior:

.. code-block:: python
    :linenos:
    :emphasize-lines: 6

    def text_conte_caracter(text, caracter):
        trobat = False
        for i in range(0, len(text), 1):
            if text[i] == caracter:
                trobat = True
                break
        return trobat

.. note:: El ``break`` permet sortir del bucle ``for`` quan ja no ens cal continuar fins el final.

Continuem el bucle
==================

De vegades, el que volem no és finalitzar el bucle sinó passar a la següent iteració.

Per exemple, si volem desenvolupar una funció que rebi una llista de paraules i que ens retorni
només aquelles que corresponguin a nombres enters, podríem resoldre-ho amb:

.. code-block:: python
    :linenos:
    :emphasize-lines: 13, 18, 23, 24

    def nomes_enters(valors):
        """ donada una llista de strings, retorna aquells que corresponguin a valors enters
            (positius i negatius)

            >>> nomes_enters(['un', '2', '-3', '+4', '5.2'])
            [2, -3, 4]
        """
        resultat = []
        for i in range(0, len(valors), 1):
            actual = valors[i]
            if actual.isdigit():
                resultat.append(int(actual))
                continue
            if actual.startswith('+'):
                resta = substring(actual, 1, len(actual)-1)
                if resta.isdigit():
                    resultat.append(int(resta))
                continue
            if actual.startswith('-'):
                resta = substring(actual, 1, len(actual)-1)
                if resta.isdigit():
                    resultat.append(int(actual))
                continue
            continue
        return resultat

Fixat que:

* A la línia 13, un cop ja hem tractat el cas que la paraula sigui tot dígits, podem passar al
  següent element del bucle.

  Ho podríem fer també amb un ``else`` o ``elif`` però d'aquesta manera pot resultar més clar en
  algunes ocasions.

* A la línia 18 passa similar, ja hem tractat el cas que la paraula comenci amb ``+`` i, per tant,
  podem anar al següent element

* Els ``continue`` de les línies 23 i 24, en realitat no calen, doncs el flux normal d'execució ja
  hagués portat a passar a la següent iteració.

  En general, sol ser millor no posar elements que no calen.

.. note:: El ``continue`` permet de la iteració actual dins del bucle ``for`` quan ja hem finalitzat
   el seu tractament.

----

*Ref. 15.5*
