#####################
La classe *Categoria*
#####################

Comencem amb la implementació de les categories.

La classe *Categoria*
=====================

La implementació de la classe *Categoria* serà:

.. literalinclude:: _recursos/dbcovid/animals/Categoria.java
   :linenos:
   :lines: 7-
   :lineno-start: 7
   :language: java
   :caption: :download:`src/main/java/Categoria.java <_recursos/dbcovid/animals/Categoria.java>`

Aquesta classe ofereix dues maneres de construir instàncies: amb o sense
identificador. Quan la instància és creada al nostre programa, no disposem
d'identificador de la base de dades, clar, encara no ha estat inserida! En
canvi, quan creem la instància a partir de les dades d'un registre de la
base de dades, sí que sabem el seu *id*.

El mètode ``toString()`` mostrarà com a indefinit l'identificador de les
instàncies que no en disposin.

El mètode ``idIndefinit()`` ens permet saber si l'identificador ha estat o
no definit a la categoria. En fer-ho d'aquesta manera, ens permetrà que
els usuaris de *Categoria* no hagin de saber que internament fem servir el
-1 per indicar que està indefinit l'identificador.

La taula *CATEGORIES*
=====================

La taula en la que emmagatzemarem la informació de les instàncies de
*Categoria* es dirà *CATEGORIES* i tindrà la següent definició:

.. code-block:: sql

    CREATE TABLE CATEGORIES (
        id   INTEGER PRIMARY KEY AUTOINCREMENT,
        nom  VARCHAR(40)
    )


Codi de creació de la taula
===========================

Tot i que podríem crear aquesta taula directament al SGBD, ho farem a
partir d'un programa en Java.

El codi que afegim a la classe *Zoo* per crear la taula és el següent:

.. literalinclude:: _recursos/dbcovid/animals/v2_creacategories/Zoo.java
   :linenos:
   :lines: 36-51
   :lineno-start: 36
   :language: java
   :caption: :download:`src/main/java/Zoo.java <_recursos/dbcovid/animals/v2_creacategories/Zoo.java>`


Cridarem aquesta funció des de *Main*:

.. literalinclude:: _recursos/dbcovid/animals/v2_creacategories/Main.java
   :linenos:
   :lines: 7-
   :lineno-start: 7
   :language: java
   :caption: :download:`src/main/java/Main.java <_recursos/dbcovid/animals/v2_creacategories/Main.java>`

Fixa't que he compactat una mica el codi, tot realitzant la crida dins del
``println()``, però que és el mateix que abans.

Execució i comprovació
======================

Si executem el codi anterior (``gradle run``) ens mostrarà els següents
missatges:

.. code-block:: none

    Primer connectem amb la base de dades: Connectat a animals.bd
    Creem la taula CATEGORIES: Creada taula CATEGORIES
    Finalment tanquem la connexió amb la base de dades: Desconnectat

És a dir, teòricament ens ha creat la taula *CATEGORIES*. Comprovem-lo
amb:

.. code-block:: none

    $ sqlite3 animals.bd ".schema CATEGORIES"
    CREATE TABLE CATEGORIES (       id        INTEGER PRIMARY KEY AUTOINCREMENT,       nom       VARCHAR(40));

Fa bona pinta, no?

Per cert, pots veure les opcions disponibles de SQLite fent ``sqlite3 -help``, i totes les comandes internes,
entrant a la shell, i demanant ajuda:

.. code-block:: none

    $ sqlite3 
    SQLite version 3.27.2 2019-02-25 16:06:06
    Enter ".help" for usage hints.
    Connected to a transient in-memory database.
    Use ".open FILENAME" to reopen on a persistent database.
    sqlite> .help
    …
    .help ?-all? ?PATTERN?   Show help text for PATTERN
    …
    .quit                    Exit this program
    …
    .schema ?PATTERN?        Show the CREATE statements matching PATTERN
    …
    .tables ?TABLE?          List names of tables matching LIKE pattern TABLE
    …

Fixa't que pots demanar-hi ajut amb ``.help`` i sortir amb ``.quit``


☼ Compactem el codi amb el *try-with-resources*
===============================================

El codi de ``creaTaulaCategories()`` es pot simplificar gràcies a una
ampliació relativament recent del ``try`` de Java. És el que es coneix com
`try with resources
<https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html>`

Bàsicament es un *try* que indica que s'intenti fer quelcom amb un recurs
que finalment serà tancat passi el que passi. 

El codi del nostre mètode ``creaTaulaCategories()`` podria quedar de la
següent manera:

.. code-block:: java
    :linenos:

    public String creaTaulaCategories() throws SQLException {
        String sql = "CREATE TABLE  CATEGORIES (" +
            "                id     INTEGER PRIMARY KEY AUTOINCREMENT," +
            "                nom    VARCHAR(40))";
        eliminaTaulaCategories(); // eliminem si ja existia
        try (Statement st = conn.createStatement()) {
            st.executeUpdate(sql);
            return "Creada taula CATEGORIES";
        }
    }

A partir d'ara, el codi te'l presentaré d'aquesta manera. Si a tu t'agrada
més l'altra, tu manes en el teu codi.


Eliminació de la taula
======================

Què passaria si tornéssim a executar el nostre *Main*?

Provem-ho!

.. code-block:: none
    :linenos:

    $ gradle run

    > Task :run FAILED
    Primer connectem amb la base de dades: Connectat a animals.bd
    Creem la taula CATEGORIES: Exception in thread "main" java.sql.SQLException: table CATEGORIES already exists
            at org.sqlite.core.NativeDB.throwex(NativeDB.java:397)
            at org.sqlite.core.NativeDB._exec(Native Method)
            at org.sqlite.jdbc3.JDBC3Statement.executeUpdate(JDBC3Statement.java:116)
            at Zoo.creaTaulaCategories(Zoo.java:46)
            at Main.main(Main.java:15)

    FAILURE: Build failed with an exception.

    * What went wrong:
    Execution failed for task ':run'.
    > Process 'command '/usr/lib/jvm/java-11-openjdk-amd64/bin/java'' finished with non-zero exit value 1

    * Try:
    Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.

    * Get more help at https://help.gradle.org

    BUILD FAILED in 667ms
    2 actionable tasks: 1 executed, 1 up-to-date

Ops! Què ha passat? Si tot anava tant bé?

La línia 5 és prou explícita; *la taula CATEGORIES ja existeix*

És clar, estem intentant crear una taula que ja existeix. Tenim diferents
opcions per resoldre aquest problema. 
Potser la més radical és simplement eliminar el fitxer ``animals.bd``!
La que farem servir aquí, donat que
és un exemple de *joguina* és eliminar la taula existent abans de
crear-la.

És tracta d'un ``executeUpdate()`` sobre la sentència ``DROP TABLE IF EXISTS CATEGORIES``.

A banda de crear el mètode ``Zoo.eliminaTaulaCategories()``, afegeix com a
primera línia de ``Zoo.creaTaulaCategories()`` la sentència següent:

.. code-block:: java

    public String creaTaulaCategories() throws SQLException {
        eliminaTaulaCategories(); // eliminem si ja existia
        Statement st = null;
        // …
    }

Exercici 1. Elimina la taula *CATEGORIES*
=========================================

Implementa el mètode ``Zoo.eliminaTaulaCategories()`` de manera que es
pugui executar sense error el *Main* més d'una vegada.

Afegir una categoria
====================

Ara que ja tenim la taula *CATEGORIES*, hi podem afegir categories.

La sentència SQL seria quelcom similar a:

.. code-block:: sql

    INSERT INTO CATEGORIES (nom) VALUES ('ocell');

Aquí ``'ocell'`` és el nom de la categoria que volem crear. El seu
identificador ens el crearà SQLite.

El mètode que ens inserirà una categoria en la base de dades serà:

.. code-block:: java
    :linenos:

    public String afegeixCategoria(Categoria categoria) throws SQLException {
        String sql = "INSERT INTO CATEGORIES (nom) VALUES ('"
            + categoria.getNom()
            + "')";
        try (Statement st = conn.createStatement()) {
            int num = st.executeUpdate(sql);
            return "Nombre de categories afegides: " + num;
        }
    }

Fixa't com, a la línia composem la sentència SQL, mentre que a la 8 la
llancem.

No ho havíem vist fins ara però, ``executeUpdate()`` ens retorna un valor
que ens indica el nombre de registres afectats amb l'execució.

Per cridar-lo, simplement afegirem al nostre *Main* les següents línies,
tot just després d'haver creat la taula *CATEGORIES*:

.. code-block:: java

        Categoria ocell = new Categoria("ocell");
        System.out.print("Inserim " + ocell + ": ");
        System.out.println(zoo.afegeixCategoria(ocell));


En executar-lo el primer cop, ens trobem els missatges:

.. code-block:: none

    Primer connectem amb la base de dades: Connectat a animals.bd
    Creem la taula CATEGORIES: Creada taula CATEGORIES
    Inserim Categoria(id:indefinit, ocell): Nombre de categories afegides: 1
    Finalment tanquem la connexió amb la base de dades: Desconnectat

Fixa't que l'identificador apareix com a indefinit. Clar, des del nostre
programa no sabem quin identificador li ha assignat SQLite,

Comprovem que ens ha afegit correctament la categoria:

.. code-block:: none

    $ sqlite3 animals.bd "select * from categories"
    1|ocell

Fa bona pinta, no?

Exercici 2. Afegir la categoria *mamífer*
=========================================

Afegeix el codi necessari per crear la categoria *mamífer*.

Pista: només hauries de tocar *Main.java*.

Recuperar les categories
========================

Per recuperar informació d'una base de dades relacional, el que ens cal és
composar una consulta, també coneguda com a *query* o directament *SELECT*.

La sentència mínima necessària per recuperar totes les categories seria la
que ja hem vist abans per comprovar, des de línia de comandes, que havíem
inserit correctament *ocell*. Per donar-li una mica més de color, aquí li
demanarem un cert ordre.

.. code-block:: sql

    SELET * FROM CATEGORIES ORDER BY nom;

En primer lloc, implementarem el mètode ``Zoo.recuperaCategories()`` que
tindrà el següent codi:

.. code-block:: java
    :linenos:

    public List<Categoria> recuperaCategories() throws SQLException {
        String sql = "SELECT * FROM CATEGORIES ORDER BY nom";
        try (Statement st = conn.createStatement()) {
            ResultSet rs = st.executeQuery(sql);
            List<Categoria> categories = new ArrayList<>();
            while (rs.next()) {
                int bdId = rs.getInt("id");
                String nom = rs.getString("nom");
                Categoria categoria = new Categoria(bdId, nom);
                categories.add(categoria);
            }
            rs.close();
            return categories;
        }
    }

El codi presenta les següents particularitats:

* Fa servir la clase *ResultSet* que encapsula, com bé indica el seu nom,
  un conjunt de resultats obtinguts a partir d'una consulta. Malgrat
  indiqui el nom *conjunt*, en aquest cas, sí hi ha un ordre. Per exemple,
  en el nostre cas, la clàusula *ORDER BY* defineix que sigui ordenat de
  manera creixent per nom de categoria.

* En comptes de ``executeUpdate()`` ara fem ``executeQuery()``. És el
  mètode específic de JDBC quan el que volem és executar una consulta. En
  fer-ho, ens retornarà un *ResultSet*.

* Per poder mostrar els valors recuperats, hem d'anar recorrent els
  diferents valors del *ResultSet*. 

  *ResultSet* també es sol conèixer com a *cursor* donat que funciona com
  un cursor o índex a una llista. 

  El primer cop que cridem al mètode ``next()``, el cursor es col·loca al
  primer resultat. A mida que anem fent crides a ``next()`` el cursor va
  passant al següent resultat disponible fins arribar al darrer; moment en
  que retornarà *false*.

  El resultat que hi ha al cursor es pot accedir directament a partir de
  la variable *rs*. Fixa't com obté el primer camp que esperem que sigui
  enter doncs és l'identificador, i el segon, de tipus String, doncs és el
  nom.

* Per cada resultat, el codi crea una nova instància de *Categoria* amb
  els valors d'identificador i nom trobats, i l'afegeix a la llista de
  categories trobades, que retornarem finalment si no hi ha cap problema.

* Fixa't que finalment tanquem el *ResultSet*. És una bona pràctica, quan
  ja no necessitem el *ResultSet* el tancar-lo. Pensa que el resultat pot
  ser un nombre realment gran de registres i que, per qüestions
  pràctiques, sovint el SGBD no ens els enviarà tots de cop. Si ja sabem
  que no ens cal més, en tancar el *ResultSet* estem dient-li al SGBD que
  no cal que continuï mantenint els recursos associats a aquest.

  En aquest exemple concret, no és gaire important, doncs de seguida
  tancarem el *Statement* amb el que quedaran tancats tots els *ResultSet*
  oberts.

La teva llista d'*imports* a *Zoo.java* passarà a ser:

.. code-block:: java

    import java.sql.DriverManager;
    import java.sql.Connection;
    import java.sql.Statement;
    import java.sql.ResultSet;
    import java.sql.SQLException;

    import java.util.List;
    import java.util.ArrayList;

Per realitzar la crida a aquest nou mètode, i també per mostrar els
resultats, ens resultarà còmode crear un mètode a *Main* que ho faci. Per
exemple:

.. code-block:: java
    :linenos:

    public static void mostraCategories(Zoo zoo) throws SQLException {
        System.out.print("Recupera les categories: ");
        List<Categoria> categories = zoo.recuperaCategories();
        if (categories.size() == 0) {
            System.out.println("cap categoria trobada");
        } else {
            System.out.println("Nombre de categories trobades = " + categories.size());
            for (Categoria categoria: categories) {
                System.out.println("\t" + categoria);
            }
        }
    }

No oblidis afegir el *import* que falta ni la crida a
``mostraCategories()`` al ``main()`` tot just després d'afegir
*mamífer*.

El resultat d'executar-ho, t'hauria de donar el següent:

.. code-block:: none

    Primer connectem amb la base de dades: Connectat a animals.bd
    Creem la taula CATEGORIES: Creada taula CATEGORIES
    Inserim Categoria(id:indefinit, ocell): Nombre de categories afegides: 1
    Inserim Categoria(id:indefinit, mamífer): Nombre de categories afegides: 1
    Recupera les categories: Nombre de categories trobades = 2
            Categoria(id:2, mamífer)
            Categoria(id:1, ocell)
    Finalment tanquem la connexió amb la base de dades: Desconnectat

Fixa't que aquestes categories **sí** tenen identificador!


Insercions múltiples
====================

Cada cop que executem una sentència SQL, el SGBD ha de fer una certa
quantitat de feina. Per exemple, l'ha d'interpretar, optimitzar, etc.
Això comporta una càrrega que, de tenir molts *clients* demanant, pot
significar endarreriments o fallades de servei.

Per aquesta raó, a banda de tancar recursos quan ja no els necessitem,
també es realitzen d'altres optimitzacions. Una de molt típica és la
inserció múltiple.

Aquí tens una demostració. Considera aquest nou mètode 

.. code-block:: java
    :linenos:

    public String afegeixCategories(List<Categoria> categories) throws SQLException {
        String sql = "INSERT INTO CATEGORIES (nom) values (?)";
        try (PreparedStatement ps = conn.prepareStatement(sql)) {
            // obté l'estat anterior de l'autocommit.
            boolean anteriorAutoCommit = conn.getAutoCommit();
            // fem que no faci autocommit a cada execució
            conn.setAutoCommit(false);
            try {
                // afegeix cada categoria de la llista
                for (Categoria categoria: categories) {
                    ps.setString(1, categoria.getNom());
                    ps.executeUpdate();
                }
                // si no hi ha problemes accepta tot
                conn.commit();
                return "Nombre de categories afegides: " + categories.size();
            } catch (SQLException e) {
                // trobat problemes amb la inserció: tot enrere
                conn.rollback();
                throw e;
            } finally {
                // tornem l'estat de autocomit tal i com estava
                conn.setAutoCommit(anteriorAutoCommit);
            }
        }
    }

En aquesta ocasió, en comptes d'un *Statement*, fem servir un
*PreparedStatement*. La diferència és que la sentència SQL deixa amb
interrogants (``?``) els valors a inserir.

Aquests valors són afegits dins d'un bucle per cada instància que rebem de
*Categoria*.

Aquest codi afegeix una complexitat addicional: la inserció es fa de
manera atòmica o com a transacció. Això fa que, si falla alguna de les
insercions, anul·lem totes les anteriors (*rollback*).

El codi per cridar aquest nou mètode des de *Main* podria ser:

.. code-block:: java
    :linenos:

    List<Categoria> novesCategories = Arrays.asList(
            new Categoria("peix"),
            new Categoria("rèptil")
            );
    System.out.print("Inserim més categories: ");
    System.out.println(zoo.afegeixCategories(novesCategories));

    mostraCategories(zoo);

Aquest codi fa servir ``java.util.Arrays`` perquè ens simplifica la
creació de la llista, i finalment torna a cridar ``mostraCategories()``
per mostrar que s'han inserit totes.

El resultat de l'execució és:

.. code-block:: none

    Primer connectem amb la base de dades: Connectat a animals.bd
    Creem la taula CATEGORIES: Creada taula CATEGORIES
    Inserim Categoria(id:indefinit, ocell): Nombre de categories afegides: 1
    Inserim Categoria(id:indefinit, mamífer): Nombre de categories afegides: 1
    Recupera les categories: Nombre de categories trobades = 2
            Categoria(id:2, mamífer)
            Categoria(id:1, ocell)
    Inserim més categories: Nombre de categories afegides: 2
    Recupera les categories: Nombre de categories trobades = 4
            Categoria(id:2, mamífer)
            Categoria(id:1, ocell)
            Categoria(id:3, peix)
            Categoria(id:4, rèptil)
    Finalment tanquem la connexió amb la base de dades: Desconnectat

Exercici 3. Fes funcionar el codi fins aquí
===========================================

Acaba de composar tot el codi que tenim fins ara, de manera que en
executar *Main* obtinguis aquesta sortida indicada.
