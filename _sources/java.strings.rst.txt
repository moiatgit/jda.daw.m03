###############
Strings en Java
###############

Ja hem vist a :doc:`java.tipus`, els Strings (cadenes de caràcters) no són, en Java, un tipus
primitiu, sinó el que es coneix com *objecte*. Malgrat en aquesta primera visió del llenguatge estem
evitant tractar els objectes, amb els Strings farem una excepció, donat que els farem servir en
molts dels nostres primers programes.

Així, a aquesta secció trobaràs una visió resumida de les operacions més bàsiques que habitualment
fem amb Strings.


Concatenació de strings
=======================

A l'igual que Python, Java ens ofereix l'operador ``+`` per concatenar strings.
Així

.. code-block:: none

    jshell> "hola" + " i " +  "adeu"
    $1 ==> "hola i adeu"

Comparació d'igualtat
=====================

A Python, la comparació entre strings era igual que entre altres tipus de dades
com ara enters.

Per exemple:

.. code-block:: python
    :linenos:

    >>> cognom1 = 'Rossum'
    >>> cognom2 = input()   # introduïm Rossum
    Rossum
    >>> cognom2
    'Rossum'
    >>> cognom1 == 'Rossum'
    True

Fixa't que ``cognom1`` i ``cognom2`` fan referència al mateix valor ``'Rossum'``
L'operador d'igualtat ``==`` ens retorna ``True``.

Veiem un codi similar amb Java.

.. code-block:: none
    :linenos:

    jshell> java.util.Scanner entrada = new java.util.Scanner(System.in);
    entrada ==> java.util.Scanner[delimiters=\p{javaWhitespace}+] ... \E][infinity string=\Q∞\E]
    jshell> String cognom1 = "Gosling";
    cognom1 ==> "Gosling"

    jshell> String cognom2 = entrada.next();    // introduïm Gosling
    Gosling
    cognom2 ==> "Gosling"

    jshell> cognom1 == cognom2
    $4 ==> false

    jshell> cognom1.equals(cognom2)
    $5 ==> true

    jshell> cognom2.equals(cognom1)
    $6 ==> true

    jshell> cognom1.equals("Gosling")
    $7 ==> true

    jshell> "Gosling".equals(cognom1)
    $8 ==> true

Com podem veure a la línia 10, quan comparem amb ``==``, Java ens retorna fals!
Això pot confondre inicialment, especialment quan Python donava cert!

Per poder entendre el que està passant, cal considerar que les variables
``cognom1`` i ``cognom2`` **no** contenen el valor ``"Gosling"`` sinó que fan
referència a una posició de memòria que conté aquest valor. De fet, cada
variable apunta a una posició diferent de memòria que, casualment, contenen els
mateixos valors.

Podríem dir que el valor *real* de les variables ``cognom1`` i ``cognom2`` són
aquestes adreces de memòria i no ``"Gosling"``. Per tant, quan estem comparant
``cognom1 == cognom2``, en Java realment estem comparant posicions de memòria!

Per poder comparar els continguts de les posicions de memòria apuntades per les
dues variables, ens cal fer servir la funció ``equals()`` tal i com es mostra a
l'exemple.

.. important:: Per comparar strings en Java farem servir la funció ``equals()``.

Per què això no passa amb Python? Doncs en realitat sí que passa. Les variables
``cognom1`` i ``cognom2`` fan referència a posicions de memòria diferents. Amb
tot, la definició de l'operador d'igualtat ``==`` és una mica més *humana* i no
compara els valors de les dues variables (les posicions de memòria que contenen
els valors de tipus string) sinó aquells valors directament.

Per entendre'ns, quan en Python escrivim ``cognom1 == cognom2`` en realitat i
encara que no ens en adonem, el que Python està fent és
``cognom1.__eq__(cognom2)`` i la funció ``__eq__()`` ve a fer el mateix que
``equals()`` de Java.

I perquè Java sí permet la comparació directa d'altres tipus, com ara enters?

.. code-block:: none
    :linenos:
    :lineno-start: 24

    jshell> int valor1 = 42;
    valor1 ==> 42

    jshell> int valor2 = entrada.nextInt();
    42
    valor2 ==> 42

    jshell> valor1 == valor2
    $11 ==> true

Doncs això té a veure amb la diferència entre tipus primitius i objectes. Pels
tipus primitius, el valor de la variable és directament el valor assignat i no
una referència a la posició de memòria on s'emmagatzema aquest valor.

En resum, en Java compararem:

* ``v1 == v2`` si ``v1`` i ``v2`` són de tipus primitiu

* ``v1.equals(v2)`` si ``v1`` no és de tipus primitiu, per exemple, string


Conversions
===========

La API de Java ens ofereix diferents maneres per a realitzar conversions entre els diferents tipus
primitius i els Strings. Aquí veurem les dels tipus que més farem servir en aquest curs.

.. code-block:: java
    :linenos:

    int valorEnter = Integer.parseInt("12345");
    double valorDecimal = Double.parseDouble("123.45");
    String cadenaEntera = String.valueOf(valorEnter);
    String cadenaDecimal = String.valueOf(valorDecimal);
    String unaAltraManera = "" + valorEnter;    // aprofita la concatenació
    String encaraUnaAltra = Integer.toString(valorEnter);

Els elements d'un String
========================

A l'igual que en Python, els strings en Java són
*immutables*. És a dir, que un cop inicialitzat, no podem canviar cap caracter
d'un string.
Per exemple, per posar a majúscules la inicial d'una paraula i la resta a minúscules,
ens caldrà fer quelcom similar al següent:

.. code-block:: java
    :linenos:

    String paraula = "cAmElL";
    char inicial = paraula.charAt(0);                           // 'c'
    String resta = paraula.substring(1);                        // "AmElL"
    char inicialMajuscules = Character.toUpperCase(inicial);    // 'C'
    String restaMinuscules = resta.toLowerCase();               // "amell"
    String paraulaCapitalitzada = inicialMajuscules + restaMinuscules;
    System.out.println(paraulaCapitalitzada);                   // escriu: Camell

Al fragment de codi anterior:

* línia 1: declara i inicialitza un String

* línia 2: extreu un caràcter de la paraula (seria l'equivalent al
  ``paraula[0]`` de Python

* línia 3: crea una nova paraula sense la primera lletra (equivalent al
  ``paraula[1:]`` de Python.

* línia 4: aconseguim la versió majúscules d'un caràcter (``inicial.upper()`` a
  Python)

* línia 5: aconseguim la versió d'un String amb totes les lletres en minúscules

* línia 6: crea un nou String amb la concatenació d'un caràcter i un String


Per saber més
=============

Trobaràs un munt d'altres possibilitats de manipulació i de conversió a i de Strings a:

* API `Strings <http://docs.oracle.com/javase/8/docs/api/index.html?java/lang/String.html>`_
* API `Integer <http://docs.oracle.com/javase/8/docs/api/index.html?java/lang/Integer.html>`_
* API `Double <http://docs.oracle.com/javase/8/docs/api/index.html?java/lang/Double.html>`_
* API `Character <http://docs.oracle.com/javase/8/docs/api/index.html?java/lang/Character.html>`_

.. _exercici_manipulantstrings:

Exercici 1. Manipulant Strings
==============================

En aquest exercici et toca revisar la documentació oficial.

Considera que disposes d'una referència a String anomenada ``paraula`` que conté una paraula amb un
mínim de quatre lletres.

Proposa un codi que mostri:

#. La segona lletra de la paraula


#. La longitud de la paraula (quantes lletres conté)


#. La darrera lletra de la paraula


#. La paraula amb totes les lletres en majúscules


#. La paraula amb la darrera lletra moguda a l'inici (ex. si era "Hola" mostra "aHol")


#. La paraula amb les primeres tres lletres en majúscules i la resta en minúscules

Pots fer servir ``jshell`` per fer les proves.

----

*Ref. IP17.6*
