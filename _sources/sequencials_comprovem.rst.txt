#######################
Comprovem els programes
#######################

D'acord, sembla que amb una mica de pràctica podem anar agafant-li el truc a
això de programar, oi?

Hi ha, però, un punt que no acaba d'estar resolt. Cada cop que fem un programa,
l'hem de provar. És una part més o menys mecànica i tediosa, però
imprescindible.

De moment, els programes són facilets i, per tant, les proves també.
Bàsicament realitzes l'exemple d'execució que inclous a la capçalera i
comproves visualment que el resultat coincideix amb l'esperat.

Amb tot, imagina't que vols tenir la certesa que el resultat és **exactament**
l'esperat. És més, imagina't que volguessis fer aquesta comprovació sense
necessitat d'haver de mirar tu el resultat, fent que algú altre ho comprovés
per tu.

Doncs això és el que mirarem de fer ara: automatitzar la prova dels
nostres programes!

Considera novament el programa ``saludausuari.py``:

.. literalinclude:: _code/saludausuari.py
    :language: python
    :linenos:

Ara, crea un fitxer anomenat ``entrada.txt`` que contingui un nom
d'usuari, per exemple:

.. code-block:: none

    Manel

I aquí ve el truc! El que farem és redireccionar l'entrada del nostre
programa de manera que, en comptes del teclat, reculli el contingut del
fitxer ``entrada.txt``

.. code-block:: none

    $ python3 saludausuari.py < entrada.txt
    Com et dius?
    Hola manel. M'encanta saber de tu

Fixa't que ara no apareix l'entrada ``Manel`` que sí trobàvem quan
executavem el programa sense redireccionar l'entrada.

Aquesta informació en realitat no formava part de la sortida sinó que era
l'eco que el sistema operatiu fa quan escrivim amb el teclat.

Hem redireccionat l'entrada. Passem a redireccionar la sortida:

.. code-block:: none

    $ python3 saludausuari.py < entrada.txt > sortida.txt

Ara el nostre programa no mostra cap resultat per pantalla. En canvi, s'ha
creat un fitxer anomenat ``sortida.txt`` que conté el que hauria escrit
per pantalla.

.. code-block:: none

    $ cat sortida.txt
    Com et dius?
    Hola manel. M'encanta saber de tu

Podríem limitar-nos a comprovar visualment que aquest fitxer conté
l'esperat, però encara ho podem fer millor!

Crea ara un fitxer anomenat ``sortida_esperada.txt`` que contindrà la
sortida que esperem del nostre programa. En aquest cas:

.. code-block:: none

    Com et dius?
    Hola manel. Encantat de saludar-te

Fixa't que no és ben bé la sortida que esperem!

Ara farem servir una utilitat de GNU anomenada ``diff``. Es tracta d'un
programa que ens mostra les diferencies de continguts de fitxers de text.

Per exemple, si executem:

.. sidebar:: La utilitat ``diff``

    La utilitat ``diff`` ens permet comparar el contingut de fitxers línia
    a línia.

    Quan no hi ha diferència entre els dos fitxers comparats, ``diff`` no
    produeix cap sortida.

    Quan hi ha diferència la sortida per defecte indica:

    * context

      Es tracta de dos nombres separats per una lletra ``a``, ``c`` o ``d`` tot indicant, respectivament, que s'ha afegit, canviat o eliminat

      El primer nombre correspon a la línia que s'està comparant en el
      primer fitxer, mentre que el segon correspon a la línia del segon.

    * línies comparades separades per ``---``.

    Pots trobar tot el detall de les moltes opcions que ofereix l'eina
    amb:

    .. code-block:: none

        $ man diff

.. code-block:: none

    $ diff sortida.txt sortida_esperada.txt
    2c2
    < Hola manel. M'encanta saber de tu
    ---
    > Hola manel. Encantat de saludar-te

Fixa't com ens està mostrant que ``sortida.txt`` i
``sortida_esperada.txt`` no contenen el mateix.

Si ara fem que tots dos fitxers continguin el mateix, comprovarem que
``diff`` no ens dóna cap sortida. En el món GNU/Linux això sol indicar que
tot ha anat bé.

.. code-block:: none

    $ cp sortida.txt sortida_esperada.txt
    $ cat sortida.txt
    Com et dius?
    Hola manel. Encantat de saludar-te
    $ cat sortida_esperada.txt
    Com et dius?
    Hola manel. Encantat de saludar-te
    $ diff sortida.txt sortida_esperada.txt

Amb això ja ho tenim! Si en fer el ``diff`` no ens dóna cap resultat, és
que tot ha anat bé. És a dir, sense mirar visualment si el resultat és bo,
podem saber-ho!

Encara ho podem fer millor. La següent execució ens permet fer la
comprovació sense necessitat de generar el fitxer ``sortida.txt``

.. code-block:: none

    $ python3 saludausuari.py  < entrada.txt  | diff - sortida.esperada.txt

En aquest cas, com era d'esperar, ``diff`` no ens generarà cap sortida,
tot indicant que el generat i l'esperat són el mateix.

Per descomptat, podríem fer més d'una prova. Per exemple, considera
que fem tres proves amb els fitxers:

* ``entrada1.txt``:

  ``Manel``

* ``entrada2.txt``:

  ``Isaac``

* ``entrada3.txt``:

  ``Anna``

Amb els corresponents fitxers de sortida:

* ``sortida_esperada1.txt``:

  .. code-block:: none

        Com et dius?
        Hola Manel. M'encanta saber de tu

* ``sortida_esperada2.txt``:

  .. code-block:: none

        Com et dius?
        Hola Isac. M'encanta saber de tu

* ``sortida_esperada3.txt``:

  .. code-block:: none

        Com et dius?
        Hola Manel. M'encanta saber de tu

Sí, aquest està malament! És per veure alguna cosa fallant!

Ara, hauríem de fer una execució per cada prova, tal i com hem vist.

.. code-block:: none

    $ python3 saludausuari.py  < entrada1.txt  | diff - sortida.esperada1.txt
    $ python3 saludausuari.py  < entrada2.txt  | diff - sortida.esperada2.txt
    $ python3 saludausuari.py  < entrada3.txt  | diff - sortida.esperada3.txt
    2c2
    < Hola Anna. M'encanta saber de tu
    ---
    > Hola Manel. M'encanta saber de tu

Comprovem que el tercer joc de proves no ha anat bé. Aquí el problema està
al joc de proves, però un cop estigui corregit, si falla, probablement
serà un problema del nostre programa.

.. note::

    T'he preparat un petit guió en ``bash script`` per simplificar-te la feina
    de comprovació. El pots descarregar :download:`test_py.sh
    <_recursos/test_py.sh>`.
    Per fer-ho anar, per exemple, col·loquem els fitxers d'entrada i sortida a una mateixa carpeta, juntament amb el nostre programa i executem el guió:

    .. code-block:: none

        $ bash test_py.sh saludausuari.py
        Comprovant test entrada1.txt
        Comprovant test entrada2.txt
        Comprovant test entrada3.txt
        2c2
        < Hola Anna. M'encanta saber de tu
        ---
        > Hola Manel. M'encanta saber de tu

    No cal ni que el facis servir ni que l'entenguis. Potser et farà
    gràcia, però, fer-li una ullada.

Juguem una mica
===============

Pràctica 1. Noms i cognoms (reloaded)
-------------------------------------

Ja has codificat aquesta pràctica. Ara simplement cal que desenvolupis un
parell de jocs de prova per comprovar que funciona.

Et recordo l'enunciat:

Desenvolupa un programa que demani a l'usuari el seu nom. Un cop obtingut,
demanarà el seu cognom.  Finalment respondrà: ``"Ei «nom», tinc una amiga
que també és «cognom»"``.

Per fer-ho, recorda les passes:

1. Defineix una capçalera

#. Simula una execució

#. Decomposa el programa en, com a mínim tres subproblemes: obtenció de
   l'entrada, càlcul i presentació dels resultats

#. Resol cada subproblema. Si cal, decomposa'ls encara més.



Pràctica 2. Repetim una paraula (reloaded)
------------------------------------------

També ja tens codificada aquesta pràctica. Afegeix tres exemples, un amb 1
repetició, un altre amb 2 i finalment un amb 5.

Et recordo l'enunciat:

Desenvolupa un programa que demani a l'usuari una paraula i un número, i
escrigui la paraula tants cops com digui el nombre.

La interacció podria ser similar al següent:

.. code-block:: bash

    $ python3 paraularepetida.py
    Diguem una paraula:
    namaste
    Diguem quants cops la vols:
    5
    namaste namaste namaste namaste namaste

**Pistes**

- Com sempre, fes servir les passes habituals per resoldre'l

- L'operador ``*`` en Python permet multiplicar un text per un nombre i el
  resultat és que el text es repeteix tants cops com digui el nombre

  .. code-block:: python

        >>> "hola" * 3
        holaholahola

- La teva solució, perquè es separin les paraules, requerirà que aparegui un
  espai extra al final de cada repetició (incloent la darrera!)


Pràctica 3. El quadrat d'un número
----------------------------------

Desenvolupa un programa dins d'un fitxer anomenat ``quadratnum.py`` que demani
un número i escrigui el número al quadrat.

La interacció podria ser similar al següent:

.. code-block:: none

    $ python3 quadratnum.py
    Donam un número:
    4
    El quadrat de 4 és 16

Crea un mínim de dos jocs de prova **abans** de fer el programa!

**Pistes**:

- recorda que ``input()`` retorna sempre un text. Si el volem com a número, haurem de convertir-ho (mira :doc:`dades_conversio`)

- el quadrat d'un número és el resultat de multiplicar-ho per si mateix

- si no t'introdueixen un número, què passa?

Pràctica 4. La meitat d'un número
---------------------------------

Desenvolupa un programa dins d'un fitxer anomenat ``meitatnum.py`` que demani
un número i escrigui la meitat del número introduït.

La interacció podria ser similar al següent:

.. code-block:: none

    $ python3 meitatnum.py
    Donam un número:
    4
    La meitat de 4 és 2.0

Fixa't que molt probablement ens escriurà ``2.0`` en comptes de l'esperat
``2``. Python sap que en dividir poden sortir decimals i per tant

.. code-block:: python

    >>> type(4/2)
    <class 'float'>

Comprova què escriu si demanem ``5`` en comptes de ``4``.

Com sempre, crea les proves abans de codificar.

Pràctica 5. l'edat aproximada de l'usuari
-----------------------------------------

Desenvolupa un programa anomenat ``edataproximada.py`` que demani el nom de l’usuari,
l’any actual i l’any de naixement, calculi d’edat que té
l’usuari.

La interacció serà:

.. code-block:: none

    $ python3 edataproximada.py
    Quin és el seu nom?
    Midori
    Hola Midori. Quin any vas nèixer?
    1998
    I, quin any éstem?
    2018
    Doncs Midori, diria que tens 20 o 21 anys


.. _exercici_calculadorabasica_python:

Pràctica 6. una calculadora bàsica
----------------------------------

Desenvolupa una calculadora bàsica que demani a l'usuari dos operands i
mostri el resultat de realitzar les operacions bàsiques (+ - * /) sobre
els operands.

Exemple d'interacció: ::

    $ python3 calculadorabasica.py
    Primer operand?
    6
    Segon operand?
    2
    6 + 2 = 8
    6 - 2 = 4
    6 * 2 = 12
    6 / 2 = 3.0

Fes servir un únic ``print()`` per mostrar el resultat final.

Pistes:

* pots composar la resposta amb salts de línia concatenant el caràcter
  ``'\n'``.

  .. code-block:: python

        >>> s = "hola" + "\n" + "adéu"
        >>> missatge = "hola" + "\n" + "adéu"
        >>> missatge
        'hola\nadéu'
        >>> print(missatge)
        hola
        adéu

* no et preocupis si alguna operació no és vàlida pels valors introduïts.

----

*Ref. IP9.5*

