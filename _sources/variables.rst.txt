######################
Variables i paràmetres
######################

Tornem a visitar el concepte de variable i afegim algunes definicions.

Àmbit d'una variable
====================

**àmbit d'una variable**: espai dins d'un programa en que la variable pot
ser accedida.

L'àmbit d'una variable comença a partir del moment en que es declara i
finalitza quan es tanca el bloc de codi on està definida.

Per exemple, considera el següent codi en Python:

.. code-block:: python
    :linenos:

    la_meva_variable_global = 1
    def el_meu_modul(el_meu_parametre):
        la_meva_variable_local = 10 + la_meva_variable_global
        return la_meva_variable_local + el_meu_parametre

    def main():
        resultat = el_meu_modul(la_meva_variable_global * 100)
        print(resultat)    # escriu 111

És diu que una variable és **global** respecte un mòdul quan ha estat definida fora del mòdul però
és visible dins del mòdul.

La variable ``la_meva_variable_global`` pot ser accedida tant en els mòduls ``el_meu_modul()`` com
en ``main()``. Per tant, és *global* respecte a ambdós mòduls. El seu *àmbit* és tot el programa,
de la primera a la última línia

Es diu que una variable és **local** respecte un mòdul quan està definida dins del mòdul i, per
tant, no té visibilitat fora d'aquest.

La variable ``la_meva_variable_local`` està definida dins del mòdul ``el_meu_modul()`` i *només* pot
ser accedida dins del bloc del mòdul (entre les línies 3 i 4). Per exemple, si intentem accedir a
``la_meva_variable_local`` des de ``main()``, en provar d'executar-la, Python ens generarà un error
indicant-nos que la variable no està definida.

.. note:: Cal tenir present que, a Python, ``la_meva_variable_local`` pot ser consultada des de
    ``el_meu_modul()`` però no pot ser modificada. És tracta d'una particularitat de Python en la
    que no entrarem. Si tens curiositat, cerca la paraula reservada ``global`` i, si en tens molta
    de curiositat, el concepte de *clousure*.

**temps de vida d'una variable**: espai de temps en que es manté l'espai de memòria assignat a una
variable. Normalment podrem considerar que una variable roman viva fins la darrera vegada que sigui
accedida, o, per simplicitat, mentre el seu àmbit estigui en execució.

Per cert, els mòduls també tenen un àmbit. De moment només veurem mòduls globals, però molts
llenguatges permeten definir mòduls dins de mòduls. Python i Java en són dos exemples.

Ocultació de variables
======================

Quan definim en un àmbit local una variable amb el mateix nom que una global, es produeix un fenomen
anomenat *ocultació* o *overriding*.

.. code-block:: python

    >>> v = 1
    >>> def f():
    ...    v = 2
    ...    print(v)
    ... 
    >>> print(v)
    1
    >>> f()
    2
    >>> print(v)
    1

Fixa't com

* ``v`` és global pel mòdul ``f()``

* ``f()`` defineix la seva pròpia variable local ``v``

* per ``f()`` la variable ``v`` és la local (la que té assignat el ``2``)

* fora de ``f()`` la variable ``v`` és la global (l'assignada a ``1``)

El fenomen d'ocultació no es limita només a variables; també pot passar amb mòduls i altres
definicions. A banda, alguns llenguatges permeten fer referència a variables ocultades. Tornarem a
reprendre aquest tema més endavant.


Signatura d’un mòdul
====================

Anomenem signatura d’una subrutina a la descripció de la subrutina amb els paràmetres i el valor de
sortida (en cas de funció)

En pseudocodi podríem descriure la signatura de diferents mòduls de la següent manera: ::

    funció paraula_incorrecta(string) retorna boolean
    procediment dibuixa_línies(string, int)

En Python és típic fer servir la següent notació:

.. code-block:: python

    paraula_incorrecta(paraula:str) -> bool
    dibuixa_linia(str, int, int) -> int
    dibuixa_linies(paraula:str, amplada:int)
    main()

Fixa't que:

* no hem indicat el nom dels paràmetres en alguns dels mòduls

  El nom dels paràmetres no canvia la signatura però ofereix una bona descripció de què contindrà

* quan és un procediment no indiquem valor de retorn

La signatura del mòdul l'identifica respecte la resta de mòduls del seu mateix àmbit.

Model de memòria
================

Podem entendre la memòria involucrada en l'execució d'un programa com definida per dos blocs de dades més un per les
instruccions.

* *bloc de programa*: allà on es troba el codi dels programes

* *munt* o *heap*: és l'espai on es guarda el contingut de les variables que fa servir el programa.

* *pila d'execució* o *stack*: allà on es guarda els valors dels arguments i el punt de tornada quan
  acaba una subrutina.


----

*Ref. IP13.2*
