#########################
JDBC amb Model relacional
#########################

Amb aquests continguts treballarem la manera de comunicar els nostres programes
orientats a objecte amb les nostres bases de dades objecte relacionals.

A aquesta segona part es treballa amb el JDBC per a comunicar-nos amb una base
de dades que disposi d'un model relacional *bàsic*.

Estudiem el següent codi:

.. code-block:: java
    :linenos:

    public class Animal {
        private int id;     // valor de la clau primària a ANIMALS
        private String nom;
        private String categoria;
        public Animal(String nom, String categoria) {
            this(-1, nom, categoria); // encara no té identificador
        }
        public Animal(int id, String nom, String categoria) {
            this.id = id;
            this.nom = nom;
            this.categoria = categoria;
        }
        public void setId(int id)    { this.id=id;       }
        public String getNom()       { return nom;       }
        public String getCategoria() { return categoria; }
        public String toString(){
            return "(" + id + ", '" + nom + "', '" + categoria + "')";
        }
    }

i

.. code-block:: java
    :linenos:

    import java.sql.*;
    public class UsaAnimal {
        private Connection conn = null;    // connexió

        private void connecta() throws SQLException {
            if (conn==null) {
                String usuari   = "usuaribd";
                String password = "pass";
                String host     = "192.168.33.10";
                String bd       = "testbd";
                String url      = "jdbc:postgresql://" + host + "/" + bd;
                conn = DriverManager.getConnection(url, usuari, password);
                System.out.println("Connectat amb " + url);
            }
        }

        // tanca la connexió en cas que estigui connectada
        private void desconnecta() {
            if (conn != null) {
                try { conn.close(); } catch (SQLException e) {}
                System.out.println("Desconnectat");
                conn = null;
            }
        }

        // crea la taula d'animals
        private void creaTaula() throws SQLException {
            eliminaTaula(); // eliminem si ja existia
            Statement st = null;
            try {
                st = conn.createStatement();
                String sql =
                    "CREATE TABLE  ANIMALS (" +
                    "       id        SERIAL PRIMARY KEY," +
                    "       nom       TEXT,              " +
                    "       categoria VARCHAR(40))";
                st.executeUpdate(sql);
                System.out.println("Creada taula ANIMALS");
            } finally {
                if (st != null) { st.close(); }
            }
        }

        // elimina la taula d'animals si existeix
        private void eliminaTaula() throws SQLException {
            Statement st = null;
            try {
                st = conn.createStatement();
                String sql = "DROP TABLE IF EXISTS ANIMALS";
                st.executeUpdate (sql);
                System.out.println("Eliminada taula ANIMALS");
            } finally {
                if (st != null) { st.close(); }
            }
        }

        // mostra la llista d'animals
        private void consulta() throws SQLException {
            String sql = "SELECT * FROM ANIMALS ORDER BY nom";
            Statement st = null;
            try {
                st = conn.createStatement();
                ResultSet rs = st.executeQuery(sql);
                int nAnimals = 0;
                while (rs.next()) {
                    int id = rs.getInt("id");
                    String nom = rs.getString("nom");
                    String cat = rs.getString("categoria");
                    Animal animal = new Animal(id, nom, cat);
                    System.out.println(animal);
                    nAnimals++;
                }
                if (nAnimals==0) System.out.println("Cap animal de moment");
                rs.close();
            } finally {
                if (st != null) { st.close(); }
            }
        }

        // retorna el nombre d'animals que hi ha insertats
        private void comptaAnimals() throws SQLException {
            String sql = "SELECT COUNT(*) FROM Animals";
            Statement st = null;
            try {
                st = conn.createStatement();
                ResultSet rs = st.executeQuery(sql);
                rs.next();
                System.out.println("El nombre d'animals a la bd és: " + rs.getInt(1));
            } finally {
                if (st != null) { st.close(); }
            }
        }

        // afegeix un animal a la taula i obté l'id generat
        private void afegeixAnimal() throws SQLException {
            // crea l'animal
            Animal a = new Animal("canari", "ocell");
            // crea la comanda
            String sql = "INSERT INTO ANIMALS (nom, categoria) values ('"
                + a.getNom()
                + "', '"
                + a.getCategoria()
                + "')";
            // envia la comanda
            Statement st = null;
            try {
                st = conn.createStatement();
                int num = st.executeUpdate(sql, Statement.RETURN_GENERATED_KEYS);
                System.out.println("Nombre d'animals afegits: " + num);
                ResultSet rs = st.getGeneratedKeys();
                rs.next();
                int id = rs.getInt(1);
                a.setId(id);        // assignem l'id de l'animal
                System.out.println("Afegit l'animal " + a);
                rs.close();
            } finally {
                if (st != null) { st.close(); }
            }
        }

        // afegeix uns quants animals a la taula
        // Ho fa com a transacció (o tots o cap)
        // Fa servir un PreparedStatement per optimitzar repetides crides

        private void afegeixMoltsAnimals() throws SQLException {
            // plantilla de la sentència d'inserció
            String sql = "INSERT INTO Animals (nom, categoria) values (?,?)";

            // crea els animals
            Animal[] llista = {
                new Animal("estruç", "ocell"),
                new Animal("kiwi", "ocell"),
                new Animal("gos", "mamifer"),
                new Animal("bacallà", "peix"),
                new Animal("dofí", "peix")
            };

            // crea la sentència a executar (només un cop!)
            PreparedStatement ps = null;

            try {

                // obté l'estat anterior de l'autocommit.
                boolean anteriorAutoCommit = conn.getAutoCommit();

                ps = conn.prepareStatement(sql);
                try {

                    // fem que no faci autocommit a cada execució
                    conn.setAutoCommit(false);

                    // afegeix cada animal de la llista
                    for (Animal a: llista) {
                        // afegim els valors a insertar
                        ps.setString(1, a.getNom());       // primer camp
                        ps.setString(2, a.getCategoria()); // segon camp
                        ps.executeUpdate();
                        System.out.println("Afegit l'animal " + a);
                    }
                    // si no hi ha problemes accepta tot
                    conn.commit();
                } catch (SQLException e) {
                    // trobat problemes amb la inserció: tot enrere
                    conn.rollback();
                } finally {
                    // tornem l'estat de autocomit tal i com estava
                    conn.setAutoCommit(anteriorAutoCommit);
                }
            } finally {
                if (ps != null) { ps.close(); }
            }
        }

        private void corregeixAnimals() throws SQLException {
            // tenim el dofí en una categoria equivocada. Canviem-la a la BD
            String sql = "UPDATE Animals set categoria = 'mamifer' WHERE nom = 'dofí'";
            Statement st = null;
            try {
                st = conn.createStatement();
                int num = st.executeUpdate(sql);
                System.out.println("Modificat animals: " + num);
            } finally {
                if (st != null) { st.close(); }
            }
        }

        private void eliminaOcells() throws SQLException {
            // volem eliminar tots els ocells de la bd
            String sql = "DELETE FROM Animals WHERE categoria = 'ocell'";
            Statement st = null;
            try {
                st = conn.createStatement();
                int num = st.executeUpdate(sql);
                System.out.println("Eliminats ocells: " + num);
            } finally {
                if (st != null) { st.close(); }
            }
        }

        public static void main(String[] args) {
            UsaAnimal ua = null;
            try {
                ua = new UsaAnimal();
                ua.connecta();
                ua.creaTaula();
                ua.consulta();
                ua.afegeixAnimal();
                ua.afegeixMoltsAnimals();
                ua.consulta();
                ua.corregeixAnimals();
                ua.consulta();
                ua.eliminaOcells();
                ua.consulta();
                ua.comptaAnimals();
                ua.eliminaTaula();
            } catch(Exception e) {
                e.printStackTrace();
            } finally {
                if (ua != null) ua.desconnecta();
            }
        }
    }

Exercici 1. JDBC en funcionament
================================

Contesta les següents preguntes respecte el codi anterior. Algunes de
les preguntes potser requeriran que revisis la documentació oficial.

#. Quines diferències hi trobes entre executar una comanda sql que
   potencialment modifica registres i una altra que fa una consulta?

#. Què passa si tanques un *Statement* que ja està tancat?

#. Què passa si no tanques un *ResultSet*?

#. Com s'assegura aquest codi que es tanquen els *Statement* passi el
   que passi?

#. Seria possible fer servir una única instància de *Statement* per a
   totes les operacions d'aquest codi? Si contestes que sí, mostra com
   (no cal el codi complet) Si contestes que no, indica perquè?

#. Indica la diferència principal entre *Statement* i
   *PreparedStatement*.

#. Perquè hi ha dos *try* al mètode *afegeixMoltsAnimals()*?

#. Què volen dir els interrogants que apareixen a la comanda sql del
   mètode *afegeixMoltsAnimals()*?

#. Explica quin és l'objectiu que persegueixen les crides als mètodes
   *getAutoCommit()* i *setAutoCommit()* al mètode
   *afegeixMoltsAnimals()*.

#. Al mètode *afegeixMoltsAnimals()* què ha de passar perquè s'executi
   la crida al mètode *commit()*? i què per què s'executi
   *rollback()*?

#. La documentació del mètode *rollback()* ens indica que només hem de
   fer servir aquest mètode quan tenim *autocomit* inhabilitat. El
   codi anterior respecta aquest *contracte*?

#. Què fan les crides al mètode *setString()* a
   *afegeixMoltsAnimals()*?

#. Com es pot saber a quants registres ha afectat l'execució d'una
   comanda de modificació?

#. Fixa't que cada animal que es guarda a la base de dades disposa
   d'un identificador (la clau primària de la taula). Tal i com s'ha
   definit aquest programa, qui posa l'identificador dels animals, el
   codi o el SGBD? Com podem fer que l'altre part se n'assabenti?
   Podríem fer-ho a l'inrevés? És a dir, podria ser la part que no
   assigna ara l'identificador qui l'assignés? Quines implicacions
   tindria? Què consideres més adequat? Perquè?

Exercici 2. ☼ L'entorn operatiu de gestió d'animals
===================================================

Crea un nou projecte anomenat *gestoranimals* que ofereixi una senzilla consola
que permeti gestionar un conjunt d'instàncies de la classe ``Animal`` que hem
vist abans.

L'aplicació mostrarà el *prompt*: ::

    [animals]: 

L'aplicació oferirà les següents opcions:

- help

  mostra la llista de comandes vàlides

- list

  Mostra la llista d'animals a la base de dades en el següent format:
  ::

    * primera categoria (per ordre alfabètic)

        - nom primer animal de la primera categoria (per ordre
          alfabètic)

        - nom segon animal de la primera categoria

    * segona categoria

        - nom primer animal de la segona categoria

        - ..

  Si no es troba cap animal a la bd, s'indicarà amb el missatge: ::

    Cap animal

- list «categoria»

  Mostra la llista d'animals ordenats alfabèticament de la categoria
  indicada.

  El format serà idèntic que per l'opció *list*, excepte que només
  mostrarà una categoria.

  Si no es troba cap animal de la categoria indicada, s'indicarà amb
  el missatge: ::

    Cap animal

- add «nom animal» «categoria»

  Afegeix un nou animal a la categoria indicada.

  Si ja existeix un animal amb aquest nom, per a aquesta categoria,
  mostrarà el missatge d'error: ::

    Ja existeix un animal amb aquest nom per a aquesta categoria

  Si tot ha anat correctament, es mostrarà el missatge: ::

    D'acord

- del «nom animal» [ «categoria» ]

  Aquesta comanda permet eliminar un animal pel seu nom. Opcionalment
  es pot indicar la categoria a la que pertany.

  En cas que no existeixi cap animal amb aquest nom, o no existeixi
  amb el nom per la categoria indicada, es mostrarà el missatge: ::

    No es troba l'animal

  En cas que no s'especifiqui la categoria i hi hagi més d'un animal
  amb el mateix nom en diferents categories, es mostrarà el missatge i
  es tornarà mostrar el *prompt* :
  ::

    S'ha trobat aquest nom d'animal en les següents categories:

    * primera categoria (per ordre alfabètic)

    * segona categoria

    * …

    Per favor, expliciteu la categoria

  Finalment, en cas que s'hagi identificat un únic animal, es demanarà
  confirmació segons: ::

    Es procedirà a eliminar l'animal «nom animal» de la categoria «categoria»
    Segur? (S|n): 

  En cas que l'usuari respongui amb 'S' o 's', s'eliminarà l'animal de
  la base de dades i s'informarà amb el missatge: ::

    D'acord

  Si es respon amb qualsevol altre caràcter, es mostrarà el missatge:
  ::

    Cap modificació

- assign «nom animal» [ «categoria1» ] to «categoria2»

  Permet canviar la categoria d'un animal.

  En cas que no quedi clarament especificat un sol animal (com a
  l'opció *del*), es mostrarà els mateixos missatges.

  En cas de que l'animal estigui identificat, es procedirà a demanar
  confirmació amb el missatge: ::

    Es procedirà a assignar l'animal «nom animal» de la categoria «categoria1» a la categoria «categoria2»
    Segur? (S|n): 

  L'usuari rebrà el missatge corresponent com en el cas de *del*.

- quit

  Finalitzarà l'aplicació

Requeriments addicionals
------------------------

En arrencar, l'aplicació demanarà un password que farà servir per
intentar la connexió a la base de dades (la resta de dades de connexió
les posarà l'aplicació) En cas que el password proporcionat no permeti
realitzar la connexió, l'aplicació mostrarà l'error i permetrà tornar
a intentar o bé cancelar: ::

    Contrasenya incorrecta (i: tornar a intentar, c: cancelar):

En cas de cancelació, l'aplicació finalitzarà l'execució.


Pistes:
-------

#. Per simplicitat, totes les operacions que modifiquin els continguts
   de la base de dades, es realitzaran directament, sense esperar a
   que es tanqui l'aplicació.

#. Una altra simplificació acceptada consisteix en que els noms dels
   animals i categories consistiran sempre en una paraula sense
   espais. Si t'agradaria permetre multiparaules (ex. *lleó marí*), et
   proposo que, o bé substitueixis els espais per guions baixos (_), o
   bé consideris que les paraules múltiples apareixeran entre cometes.

#. Per a aconseguir que es pugui llegir el password de manera segura
   (sense fer eco del que teclegi l'usuari), i aprofitant que es
   tracta d'una aplicació de consola, podem fer servir la classe
   `java.io.Console <http://docs.oracle.com/javase/7/docs/api/java/io/Console.html>`_

   .. code-block:: java

        public class DemoPassword {
            public static void main( String[] args ) {
                java.io.Console cons = System.console();
                char[] passwd = null;
                String usuari = null;
                if (cons != null) {
                    usuari = cons.readLine("Usuari: ");
                    passwd = cons.readPassword("Password de %s: ", usuari);
                    cons.printf("Usuari: %s. Password: %s%n", usuari, new String(passwd));
                    java.util.Arrays.fill(passwd, ' '); // un cop usat, eliminem el contingut de
                                                        // passwd per minimitzar el temps que
                                                        // mantenim dades sensibles en memòria
                }
            }
        }

   Revisa la resta de l'API de la classe Console per veure si hi ha
   altres mètodes que et puguin ser d'utilitat.

