#################
Control de bucles
#################

Fins ara hem vist que els bucles ens permeten executar un mateix fragment
de codi més d'una vegada.

El bucle ``for`` ens resulta molt còmode per repetir el troç de codi fent
canviar el valor d'una variable (que anomenem *variable del recorregut*)
entre els disponibles d'una seqüència de valors. De moment aquesta
seqüència l'hem usada sempre el resultat d'un rang de valors numèrics
obtinguts a partir de l'expressió ``range(valor_inicial,
valor_següent_al_final, salt)``.

En aquesta secció, aprendrem a tenir més control sobre els bucles.

No vull arribar al final!
=========================

Segurament t'has trobat ja més d'un cop amb la situació de voler finalitzar un bucle abans d'arribar
al final, oi?

Per exemple, si volem desenvolupar una funció que retorni cert quan una lletra es troba dins d'una
frase, el codi amb ``for`` vindria a ser quelcom similar a:

.. code-block:: python
    :linenos:

    def text_conte_caracter(text, caracter):
        """ retorna True quan text conté al menys una ocurrència de
            caracter, False altrament.

            Espera que text i caracter siguin de tipus str

            >>> text_conte_caracter('Python is wonderful', 'z')
            False
            >>> text_conte_caracter('Python is wonderful', 'y')
            True
            >>> text_conte_caracter('Python is an interpreted high-level programming language for general-purpose programming. Created by Guido van Rossum and first released in 1991, Python has a design philosophy that emphasizes code readability, notably using significant whitespace. It provides constructs that enable clear programming on both small and large scales.', 'y')
            True
            >>> text_conte_caracter('z' + ('repetit' * 10000000), 'z')
            True
        """
        trobat = False
        for i in range(0, len(text), 1):
            if not trobat and text[i] == caracter:
                trobat = True
        return trobat



En el primer doctest, ``text_conte_caracter()`` ha d'arribar fins al final
del text per tenir clar que aquest no conté la lletra ``z``.

En el segon doctest, la funció ha d'arribar també fins al final, malgrat a
la segona iteració ja sap que ha de retornar ``True``.

En el tercer doctest, la funció també s'ha d'esperar fins el final del
text. La diferència és que ara el temps d'espera és una mica més llarg.
amb tot, pràcticament no ho notarem amb una màquina moderneta.

El darrer doctest, però, construeix un string amb 'z' seguit de 'repetit'
MOLTS cops. En aquest cas, l'execució **sí** que ens farà esperar una
estona. Molt trist, no trobes, tenint en comptes que, des de la primera
iteració ja sabiem la resposta?

Bash ens ofereix la utilitat ``time`` per saber quanta estona tarda en
executar-se un fitxer. Anem a comprovar-ho:

.. code-block:: none

    $ time python3 -m doctest ambfor.py

    real	0m22,185s
    user	0m21,536s
    sys	0m0,596s

Sense entrar en gaire detalls, el que ens està dient és que m'he hagut
d'esperar més de 20 segons per executar les proves.

``while`` to the rescue
=======================

Sabem resoldre aquest tipus de problemes fent servir un bucle condicional
(el ``while``), per exemple:

.. code-block:: python
    :linenos:

    def text_conte_caracter(text, caracter):
        """ « no oblidis la documentació de la teva funció »

            >>> text_conte_caracter('Python is wonderful', 'z')
            False
            >>> text_conte_caracter('Python is wonderful', 'y')
            True
            >>> text_conte_caracter('Python is an interpreted high-level programming language for general-purpose programming. Created by Guido van Rossum and first released in 1991, Python has a design philosophy that emphasizes code readability, notably using significant whitespace. It provides constructs that enable clear programming on both small and large scales.', 'y')
            True
            >>> text_conte_caracter('z' + ('repetit' * 10000000), 'z')
            True
        """
        trobat = False
        i = 0
        while not trobat and i < len(text):
            if not trobat and text[i] == caracter:
                trobat = True
            i += 1
        return trobat


En aquesta versió, no importa la longitud del text. En el moment que
trobem la lletra cercada, finalitza el bucle.

Comprovant els temps, un altra cop, trobem:

.. code-block:: none

    $ time python3 -m doctest ambwhile.py 

    real	0m1,148s
    user	0m0,564s
    sys	0m0,580s

Poc més d'un segon! No està malament la diferència, no?

Ep, que això és una funció!
===========================

Donat que estem en una funció, disposem d'una possibilitat de finalitzar
el bucle sense necessitat d'arribar al final: fent servir ``return``

.. code-block:: python
    :linenos:

    def text_conte_caracter(text, caracter):
        """ « no oblidis la documentació de la teva funció » """
        for i in range(0, len(text), 1):
            if text[i] == caracter:
                return True
        return False

Fixat com, simplement en trobar el caràcter en qüestió, ja sabem el
resultat de la funció i el podem retornar directament sense esperar el
final.

No tens curiositat per saber si va més o menys ràpid que amb ``while``?

Trenquem el bucle
=================

No sempre podem retornar dins d'un bucle. Per exemple, podria passar que
ens calgués realitzar algun càlcul més després d'haver trobat el caràcter
cercat.

Aquest tipus de problemes és molt típic. Tant, que la majoria dels
llenguatges imperatius ofereixen algun tipus de mecanisme per a afegir-hi
control.

Considera la nova versió del problema anterior:

.. code-block:: python
    :linenos:
    :emphasize-lines: 6

    def text_conte_caracter(text, caracter):
        """ « no oblidis la documentació de la teva funció » """
        trobat = False
        for i in range(0, len(text), 1):
            if text[i] == caracter:
                trobat = True
                break
        # aquí podria fer altres coses, tant si s'ha trobat com si no
        return trobat

Un ús molt típic del ``break`` és el de construir un bucle ``while`` infinit i
decidir la sortida en funció de diferents condicions.

Per exemple:

.. code-block:: python

    print("Diguem alguna cosa")
    while True:
        resposta = input()
        if resposta == 'adéu':
            print("Au, bon vent!")
            break
        print("No tens res millor a dir?")

.. note:: El ``break`` permet sortir del bucle quan ja no ens cal
          continuar fins el final.



Continuem el bucle
==================

De vegades, el que volem no és finalitzar el bucle sinó passar a la
següent iteració.

Per exemple, si volem desenvolupar una funció que rebi una seqüència de
paraules i que ens retorni només aquelles que corresponguin a nombres
enters, podríem resoldre-ho amb:

.. code-block:: python
    :linenos:
    :emphasize-lines: 12, 13

    def suma_digits(text):
        """ donat un string, retorna un nou string que contingui només els
            dígits

            >>> suma_digits('a12b3cde4f5')
            '1+2+3+4+5=15'
        """
        resultat = ''
        suma = 0
        for i in range(0, len(text), 1):
            actual = text[i]
            if not actual.isdigit():
                continue
            suma += int(actual)
            if i == 1:
                resultat += actual
            else:
                resultat += '+' + actual

        resultat += '=' + str(suma)
        return resultat

Fixat que a la línia 13, un cop hem vist que el caràcter actual no és un dígit,
demanem que continuï pel següent element del bucle. La línia 14 no serà
executada mai després d'executar la 13.

Tot plegat, el codi seria equivalent a fer el següent:

.. code-block:: python
    :linenos:
    :emphasize-lines: 13-17

    def suma_digits(text):
        """ donat un string, retorna un nou string que contingui només els
            dígits

            >>> suma_digits('a12b3cde4f5')
            '1+2+3+4+5=15'
        """
        resultat = ''
        suma = 0
        for i in range(0, len(text), 1):
            actual = text[i]
            if actual.isdigit():
                suma += int(actual)
                if i == 1:
                    resultat += actual
                else:
                    resultat += '+' + actual

        resultat += '=' + str(suma)
        return resultat

Amb tot, si tens vàries condicions per continuar, aviat els ``if`` aniuat
acaben fent molt complicat de llegir el codi.


.. note:: El ``continue`` permet de la iteració actual dins del bucle ``for`` quan ja hem finalitzat
   el seu tractament.

Exercici 62. El text transformat (revisitat)
============================================

Recordes l'exercici :ref:`El text transformat <exercici_text_transformat>`?

Aplica els nous coneixements amb ``break`` i ``continue`` de manera que no
et calgui fer servir ``elif`` ni ``else``.


Exercici 63. Desaccentua (revisitat)
====================================

Recordes l'exercici :ref:`Desaccentua <exercici_desaccentua>`?

Aplica els nous coneixements amb ``break`` i ``continue`` de manera que no
et calgui fer servir ``elif`` ni ``else``.

Exercici 64. El lloro no diu paraulotes
=======================================

Torna a considerar l'exercici del :ref:`lloro <exercici_lloro_python>`.

Fes una nova versió en la que el lloro no pugui dir cap paraula acabada en
"uta" (com per exemple, em… "ruta") ni cap que comenci amb "cabr".
Atenció: no tinguis en comptes majúscules i minúscules.

Per simplificar-ho, tampoc no podrà dir cap "paraula" que contingui
espais. És a dir, que només considerarà repetir quan sigui una única
paraula.

Així, si el que rep el lloro inclou alguna paraula "prohibida", el lloro
respondrà: "no sóc un mal parlat".

Per altra banda, la solució no ha de contenir cap ``else`` ni ``elsif``

Considera la simulació:

.. code-block:: none

    python3 lloro.py
    El lloro pregunta paraula:
    hola
    El lloro diu: hola
    El lloro pregunta paraula:
    què tal?
    El lloro diu: Només una paraula
    El lloro pregunta paraula:
    fruta
    No sóc un mal parlat
    El lloro pregunta paraula:
    Cabrales
    No sóc un mal parlat
    adéu
    Adéu

Exercici 65. El lloro no diu paraulotes (multiparaula)
======================================================

L'exercici del lloro benparlat pot ser ampliat per què sigui capaç de
tractar frases.

En aquesta versió, si en la frase introduïda hi
ha alguna paraula prohibida, el lloro canvia la part malsonant per un so
de censura que representarem amb *<piii>*.

Considera la simulació:

.. code-block:: none

    python3 lloro.py
    El lloro pregunta paraula:
    T'agrada la fruta?
    El lloro diu: T'agrada la fr<piii>?
    El lloro pregunta paraula:
    La ruta del cabrales
    El lloro diu: La r<piii> del <piii>ales
    adéu
    Adéu

Exercici 66. ☼ Treient espines
==============================

Segurament algun dels exercicis anteriors a aquesta secció t'han resultat
especialment antipàtics per haver-te vist en l'obligació d'arribar al final d'un
``for`` o bé emplenar de condicionals el cos del bucle.

Doncs aprofita aquest exercici opcional per a refer aquells exercicis.

.. note:: Revisitar el codi que vas fer fa temps, és una de les millors maneres
          de millorar les teves habilitats de programació. Si t'ho pots
          permetre, no deixis passar cap oportunitat.
