##################
Agrupació de dades
##################

A la secció anterior ens vam quedar amb la idea de que ens calia agrupar diferents conceptes d'un
resultat d'alguna manera.

Agrupant dades en C
===================

Els llenguatges de programació imperatius no orientats a objectes, resolen aquest problema de
diferents maneres. Per exemple, C fa servir *struct*

.. code-block:: c
    :linenos:
    :emphasize-lines: 29

    #include <stdio.h>
    #include <string.h>

    typedef struct {
        char estudiant[50];
        int nota;
    } Resultat;

    /*
        A partir de l'estudiant i la nota, mostra un missatge indicant si l'estudiant
        aprova o no la UF

        Entrada (paràmetres): resultat de l'estudiant
        Sortida (sortida estàndard): un missatge
            "L'estudiant «nom de l'estudiant» aprova la UF amb un «nota de la UF»." o
            "L'estudiant «nom de l'estudiant» suspèn la UF amb un «nota de la UF»."
            */
    void mostraResultat(Resultat resultat) {
        char aprovaOSuspen[7];
        if (resultat.nota < 5) {
            strcpy(aprovaOSuspen, "suspèn");
        } else {
            strcpy(aprovaOSuspen, "aprova");
        }
        printf("L'estudiant %s %s la UF amb un %d.\n", resultat.estudiant, aprovaOSuspen, resultat.nota);
    }

    int main( ) {
        Resultat resultat;
        strcpy(resultat.estudiant, "Laia Sánchez d'Àrgent");
        resultat.nota = 6;
        mostraResultat(resultat);
    }

**nota**: Una manera d'excutar aquest codi seria guardant-lo al fitxer ``exemple.c`` i executant:

.. code-block:: none

    $ gcc exemple.c && ./a.out

A la línia 29 del codi anterior, creem un ``Resultat``. És a dir, demanem a C que ens creï una
instància de tipus ``Resultat`` i li assignem a la variable ``resultat``.

A les línies posteriors, *inicialitzem* els diferents *camps* de que es composa un ``Resultat`` i,
finalment, a la línia 32 passem els valors *en bloc* al procediment
``mostraResultat()``.


Fixa't que ara seria fàcil afegir nous *camps* a un resultat, com ara el nom i cognoms de
l'estudiant per separat, el nom i el codi de la UF, etc.

.. code-block:: c

    typedef struct {
        char nomEstudiant[50];
        char cognomEstudiant[50];
        char nomUF[100];
        char codiUF[5];
        int nota;
    } Resultat;

Una possible solució en Python
==============================

En un llenguatge com Python (+3.0) disposem de les tuples amb nom (*namedtuple*), de manera que
podem traduir el codi anterior com:

.. code-block:: python
    :linenos:
    :emphasize-lines: 19

    from collections import namedtuple
    Resultat = namedtuple('Resultat', 'estudiant nota')

    def mostra_resultat_estudiant_en_UF(resultat):
        """ A partir de l'estudiant i la nota, mostra un missatge indicant si l'estudiant
            aprova o no la UF

            Entrada (paràmetres): resultat de l'estudiant
            Sortida (sortida estàndard): un missatge
                "L'estudiant «nom de l'estudiant» aprova la UF amb un «nota de la UF»." o
                "L'estudiant «nom de l'estudiant» suspèn la UF amb un «nota de la UF»."
        """
        print("L'estudiant %s %s la UF amb un %s." % (
              resultat.estudiant,
              'suspèn' if resultat.nota < 5 else 'aprova',
              resultat.nota))

    if __name__ == '__main__':
        resultat = Resultat("Laia Sánchez d'Àrgent", 6) 
        mostra_resultat_estudiant_en_UF(resultat)

**nota**: pots executar aquest codi guardant-lo en un fitxer (ex. ``exemple.py``) i executant:

.. code-block:: none

    $ python3 exemple.py

Fixa't que, a diferència de C, a Python, tant la creació de la nova instància i la inicialització,
es realitzen en la mateixa línia (la 19). Amb tot, i de la mateixa manera que en C, al codi de
Python els dos valors de que es composa el resultat, es passen agrupats al procediment
``mostra_resultat_estudiant_en_UF()``.


A l'igual que amb ``struct`` de C, el ``namedtuple`` de Python és fàcilment ampliable:

.. code-block:: python

    Resultat = namedtuple('Resultat', 'nom_estudiant cognom_estudiant nom_UF codi_UF nota')

El llenguatge Java ofereix un altre mecanisme -- les *classes* -- que, com veurem de
seguida, és molt més que una simple agrupació de dades.


Exercici 3. ☼ L'estructura Persona en C
=======================================

Implementa l'estructura d'una persona (amb nom, cognoms i edat) en llenguatge C.

Inclou el codi del mòdul ``mostra_fitxa()`` que rebi una instància de
l'estructura creada i la mostri per sortida estàndard en forma de fitxa com a
:ref:`un exercici anterior <exercici_fitxa_persona>`.

Donat que és un llenguatge que no hem fet servir aquest curs, estigues en
disposició de preguntar o cercar per internet més de l'habitual.

Exercici 4. ☼ L'estructura Persona en Python
============================================

Implementa l'estructura d'una persona (amb nom, cognoms i edat) en Python. Fes
servir ``namedtuple``.

Inclou el codi del mòdul ``mostra_fitxa()`` que rebi una instància de
l'estructura creada i la mostri per sortida estàndard en forma de fitxa com a
:ref:`un exercici anterior <exercici_fitxa_persona>`.


----

*Ref. IP19.3*
