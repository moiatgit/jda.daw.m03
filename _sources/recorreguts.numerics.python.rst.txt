####################
Recorreguts en Pyton
####################

Ara que ja tenim una idea de com funcionen els recorreguts, veiem el cas
particular de Python.

L'estructura *per* en Python s'escriu *for* i té algunes particularitats

Tornem a considerar els diferents fragments de programa amb bucles que vam veure en pseudocodi.
Aquest cop, el traduïrem a Python i, per tant, els pots provar a la consola.

.. code-block:: python

    # Primers deu nombres decimals
    #
    # var i és enter
    # Per i de 0 a 9 fer
    #   escriu i
    # Fper
    for i in range(0, 10, 1):
        print(i)

Fixat què:

* el rang de valors s'explicita amb la paraula *range* i, entre
  parèntesis, indiquem el valor inicial (en aquest cas *0*) i el següent
  del valor final. El valor tercer valor, l'*1*, indica l'increment que
  realitzem.

.. note: el límit superior del rang, en Python, és el número posterior al
    darrer que ens interessa! Més endavant potser entendrem quina és la
    raó darrera d'aquesta decisió aparentment tan extranya.


Altres exemples:

.. code-block:: python

    # Primers cinc nombres parells
    #
    # var i és enter
    # Per i de 0 a 8 inc 2 fer
    #   escriu i
    # Fper
    for i in range(0, 9, 2):        # Fixa't que ha de ser 9 perquè és 8 + 1!
        print(i)

En el cas dels decrements, farem:

.. code-block:: python

    # Primers cinc nombres parells en ordre decreixen
    #
    # var i és enter
    # Per i  de 8 a 0 dec 2 fer
    #   escriu i
    # Fper
    for i in range(8, -1, -2):
        print(i)

Fixa't que el límit final és *-1* doncs és el valor següent a l'últim que
ens interessa.

Juguem una mica
===============

Per a alguns dels següents exercicis no es requerirà que afegeixes mecanismes de prova (simulacions,
doctest). L'enunciat t'ho dirà explicitament.

Amb tot, i com sempre, assegura't que afegeixes una capçalera a cada fitxer.

De moment, però, tornarem a fer la part d'entrada/sortida que havíem abandonat un cop vam introduïr
el mecanisme de funcions.

Pràctica 1. Primers cent naturals en Python (re-loaded)
-------------------------------------------------------

Desenvolupa un programa que escrigui els primers 100 nombres naturals
en ordre creixent (un número per línia) en Python.

**Nota**: no afegeixis cap simulació, ni fitxers de comprovació d'entrada sortida, ni *doctest*.

Comprova que la sortida comença amb el valor ``0``, tot seguit ve ``1`` i així, arriba al darrer
``99``.

Si el darrer és ``100``, no has fet el que es demana!


Pràctica 2. Entre dos nombres (re-loaded)
-----------------------------------------

Desenvolupa un programa que demani dos números a l’usuari i escrigui tots els números entre el
primer i el segon, començant pel primer i acabant pel segon.

Pots provar el teu codi amb :download:`test_py.sh <_recursos/test_py.sh>` i aquests :download:`fitxers
de prova <_recursos/suport11.1.2.2.entredosnombres.tar.gz>`.

No cal que afegeixis *doctest* però sí tres simulacions, diferents de les proves proporcionades, que
considerin tots els casos que et demanava l'enunciat original: primer nombre sigui més gran, més
petit o igual que el segon.

Pràctica 3. Entre dos nombres (re-loaded again!)
------------------------------------------------

Tornem a considerar el programa ``entredosnombres.py`` i fem una nova versió. Aquest cop sí farem el
mecanisme de *doctest*. Et proposo el primer, però caldrà que afegeixis com a mínim dos casos més
per completar tots els que has preparat a la pràctica anterior.

.. code-block:: python

        >>> entre_dos_nombres(3, 6)
        '3 4 5 6 '

Per fer-ho, necessitarem poder concatenar els diferents valors del bucle en un sol string que
retornarà la funció ``entre_dos_nombres(inici, final)``. Aquesta funció rebrà els dos valors
numèrics que marquen l'inici i el final dels nombres a mostrar.

Fixa't que el resultat és diferent al que havíem fet a la versió anterior.  Per simplificar la
prova, en comptes de retornar els números en una línia cadascún, els separem amb un espai.  Per
aquesta raó, no ens serviran les proves que ja tenim de la versió anterior.

Pràctica 4. Entre dos nombres (re-loaded encara un altre cop!)
--------------------------------------------------------------

Tornem a considerar la funció `entre_dos_nombres()` del problema anterior.

Aquest cop, eliminarem l'espai final que apareix a la sortida. Considera el següent doctest:

.. code-block:: python

        >>> entre_dos_nombres(3, 6)
        '3 4 5 6'

Pràctica 5. Suma fins un nombre
-------------------------------

Desenvolupa un programa que demani un número a l’usuari i escrigui la suma de tots els números entre
l’introduït i el 1.

Et proposo les següents proves en *doctest*:

.. code-block:: python

    >>> suma_fins_un_nombre(4)
    '1 + 2 + 3 + 4 = 10'
    >>> suma_fins_un_nombre(1)
    '1'
    >>> suma_fins_un_nombre(0)
    'error'
    >>> suma_fins_un_nombre(-1)
    'error'

Fixa't que si s'introdueix 1, la sortida no mostra una suma. A més, el valor 0 i els negatius
generan un error.

Pràctica 6. Històric d'edats
----------------------------

Desenvolupa un programa que demani el nom de l’usuari, l’edat i l’any
actual. El programa escriurà l’edat que tenia l’usuari a cada any des
del seu naixement i s’acomiadarà.

L'aplicació no li dirà l'edat que té l'usuàri en l'any actual, donat
que aquesta dada forma part de l'entrada. Per exemple, si l'usuària ha
nascut aquest any, simplement s'acomiadarà, i si ho va fer l'any
passat, només dirà quan va néixer i s'acomiadarà.

Per altra banda, caldrà realitzar algunes comprovacions a l'entrada. Les comprovacions requerides
són:

* que el nom no estigui buit

  **pista**: sabem que és buit si el nom introduït és igual a ``''``

* que l'edat sigui un valor positiu (es pressuposa que serà
  enter)

* que l'any sigui com a mínim 1971 (també es pressuposa enter)

En cas d'error, sempre retornarà el mateix missatge: *Entrada errònia*

En aquest exercici no cal fer *doctest*. S'ofereixen els :download:`fitxers de prova
<_recursos/suport11.1.2.6.historicedats.tar.gz>` que pots provar amb :download:`test_py.sh
<_recursos/test_py.sh>` .


Pràctica 7. Un quadrat de nombres
---------------------------------

Escriu un programa que demani un enter positiu més gran que 0 i
"dibuixi" un quadrat amb els nombres del 1 fins el valor de l'entrada.
Per exemple, si l'entrada és 5, dibuixarà: ::

    1 2 3 4 5
    1 2 3 4 5
    1 2 3 4 5
    1 2 3 4 5
    1 2 3 4 5

En aquest exercici no cal fer *doctest* però sí fitxers externs de
comprovació.

En cas que et vulguis estalviar concatenar els diferents valors de cada
línia, pots fer servir el següent truc

.. code-block:: python

    print("Gui", end='')
    print("do")

Que en executar-ho resultarà en: ::

    Guido

Pràctica 8. Un triangle de nombres
----------------------------------

Desenvolupa un programa que demani a l’usuari un nombre positiu més
gran que 0. El programa escriurà una línia per nombre entre el 1 i el
nombre introduït (es a dir, creixentment). A cada línia escriurà tots
els nombres des del nombre corresponent a la línia fins al 1. Ex. si
l’entrada és ``5`` la sortida serà ::

    1
    2, 1
    3, 2, 1
    4, 3, 2, 1
    5, 4, 3, 2, 1

En aquest exercici no cal fer *doctest* però sí fitxers externs de
comprovació.

Pràctica 9. Un triangle invertit
--------------------------------

Desenvolupa un programa que demani a l’usuari un nombre positiu més
gran que 0. El programa escriurà una línia per nombre entre el nombre
introduït i el 1 (és a dir, decreixentment). A cada línia escriurà
tots els nombres des de l’1 fins el nombre corresponent a la línia.
Ex. si l’entrada és ``5`` la sortida serà ::

    1, 2, 3, 4, 5
    1, 2, 3, 4
    1, 2, 3
    1, 2
    1

En aquest exercici no cal fer *doctest* però sí fitxers externs de
comprovació.

Pràctica 10. Triangles
----------------------

Desenvolupa un programa que demani un nombre enter positiu i dibuixi
tants triangles com se li indiqui segons l'exemple següent on
l'entrada és ``2``. ::

    .........9.........
    ........898........
    .......78987.......
    ......6789876......
    .....567898765.....
    ....45678987654....
    ...3456789876543...
    ..234567898765432..
    .12345678987654321.
    0123456789876543210
    .........9.........
    ........898........
    .......78987.......
    ......6789876......
    .....567898765.....
    ....45678987654....
    ...3456789876543...
    ..234567898765432..
    .12345678987654321.
    0123456789876543210

Nota: evidentment s'espera que no ho facis amb instruccions de l'estil

.. code-block:: python

    print("....45678987654....")

En aquest exercici no cal fer *doctest* però sí fitxers externs de
comprovació.


Pràctica 11. Rombos
-------------------

Desenvolupa un programa que escrigui el següent ::

    .........9.........
    ........898........
    .......78987.......
    ......6789876......
    .....567898765.....
    ....45678987654....
    ...3456789876543...
    ..234567898765432..
    .12345678987654321.
    0123456789876543210
    .12345678987654321.
    ..234567898765432..
    ...3456789876543...
    ....45678987654....
    .....567898765.....
    ......6789876......
    .......78987.......
    ........898........
    .........9.........

Nota: Aquí tampoc s'espera que ho codifiquis amb instruccions de l'estil

.. code-block:: python

    print("....45678987654....")

En aquest exercici no cal fer *doctest* però sí fitxers externs de
comprovació.


-----

*Ref. IP11.1.2*
