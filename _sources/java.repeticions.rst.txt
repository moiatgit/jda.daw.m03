###########
Repeticions
###########

A banda de decidir si una instrucció ha de ser o no executada, de vegades ens interessa indicar
quants cops ha d'executar-se.

En aquesta secció veurem les instruccions de flux iteratiu que ens ofereix Java.

Java ofereix bàsicament quatre estructures per crear bucles:

* ``while``

* ``do-while``

* ``for``

* ``for`` millorat o *enhanced for*

Bucle while i do-while
======================

El ``while`` de Java és pràcticament igual que el de Python (a banda dels
parèntesis de la condició i les claus per marcar els blocs). L'estructura
``do-while``, però, no té una equivalència directa a Python.

Per exemple

.. code-block:: python

    quantes = 0
    while input() != 'prou':
        quantes += 1
    print('Paraules introduïdes: %s' % quantes)

En Java l'implementaríem amb:

.. code-block:: java
    :linenos:

    java.util.Scanner entrada = new java.util.Scanner(System.in);
    int quantes = 0;
    while (! entrada.next().equals("prou")) {
        quantes++;
    }
    System.out.printf("Paraules introduïdes: %s%n", quantes);

Java també ens permet realitzar la comprovació de la sortida del ``while`` al
final d'executar el bloc del bucle.

.. code-block:: java
    :linenos:

    java.util.Scanner entrada = new java.util.Scanner(System.in);
    int quantes = -1;
    do {
        quantes++;
    } while (! entrada.next().equals("prou"));
    System.out.printf("Paraules introduïdes: %s%n", quantes);

Fixa't que hem hagut d'inicialitzar ``quantes`` a ``-1`` doncs segur que com a
mínim entra un cop dins del bucle!


Bucle for
=========

El bucle ``for`` de Java no és exàctament el ``for`` de Python. Es tracta, però,
d'un format molt estés entre molts dels llenguatges de programació més
utilitzats (aquells basats amb la sintaxi del llenguatge C)

L'aspecte del ``for`` en Java, però, et resultarà força familiar gràcies a les
restriccions d'ús que has patit durant la major part d'aquest curs amb el
``for`` en Python.

Compara aquest codi en Python:

.. code-block:: python

    for i in range(0, 10, 1):
        print(i)

amb aquest codi equivalent en Java:

.. code-block:: java

    for (int i=0; i < 10; i = i + 1) {
        System.out.println(i);
    }

Bàsicament, els tres valors que fèiem servir a ``range()`` els trobem ara de
manera explícita, als tres elements que apareixen en el ``for`` de Java.

Bucle for millorat
==================

El ``for`` millorat de Java és molt més semblant al ``for`` de Python.

Considera el següént codi en Python:

.. code-block:: python
    :linenos:

    def inicials(sequencia):
        """ donada una seqüència de paraules (strings), retorna un string amb les
            inicials en majúscules.
            Ignora els caràcters que no siguin lletres i les paraules buides.

            >>> inicials(())
            ''
            >>> inicials(('hola',))
            'H'
            >>> inicials(('hola', 'i', 'adéu'))
            'HIA'
            >>> inicials(('%', 'adéu', '', 'i', ',', 'hola', '!'))
            'AIH'
        """
        resultat = ''
        for i in range(0, len(sequencia), 1):
            paraula = sequencia[i]
            if len(paraula) < 1:
                continue
            if not paraula[0].isalpha():
                continue
            resultat += paraula[0].upper()
        return resultat

Està fent servir el ``for`` de la manera habitual amb la que hem treballat, oi?

Però una manera més natural de resoldre aquest problema en Python seria:

.. code-block:: python
    :linenos:

    def inicials(sequencia):
        """ donada una seqüència de paraules (strings), retorna un string amb les
            inicials en majúscules.
            Ignora els caràcters que no siguin lletres i les paraules buides.
        """
        resultat = ''
        for paraula in sequencia:
            if len(paraula) < 1:
                continue
            if not paraula[0].isalpha():
                continue
            resultat += paraula[0].upper()
        return resultat

La variable ``paraula`` anirà prenent una a una cadascuna de les paraules que
conté la seqüència i, per cada valor, executarà el codi en el bloc del ``for``.

De fet, ``range(0, len(sequencia), 1)`` no deixa de ser una seqüència formada
pels nombres enters del 0 a la longitut de ``sequencia`` comptats d'un en un,
cosa que pots veure si fas:

.. code-block:: python

    >>> sequencia = ('hola', 'i', 'adéu')
    >>> tuple(range(0, len(sequencia), 1))
    (0, 1, 2)

Cal tenir present que quan fem servir el ``for`` en Python d'aquesta manera,
perdem la possibilitat de saber en quina posició dins la seqüència ens trobem a
cada iteració. [#enumerate]_

A Java podríem implementar la funció ``inicials()`` de la següent manera:

.. code-block:: java
    :linenos:

    class Test {

        /* donada una seqüència de paraules (strings), retorna un string amb les
            inicials en majúscules.
            Ignora els caràcters que no siguin lletres i les paraules buides. */
        static String inicials(String[] sequencia) {
            String resultat = "";
            for (String paraula: sequencia) {
                if (paraula.length() < 1) {
                    continue;
                }
                if (! Character.isLetter(paraula.charAt(0))) {
                    continue;
                }
                resultat += Character.toUpperCase(paraula.charAt(0));
            }
            return resultat;
        }

        public static void main(String[] args) {
            String[] laSequencia = new String[] { "hola", "i", "adéu" };
            String resposta = inicials(laSequencia);
            System.out.println("Les inicials són " + resposta);
        }
    }

Alguns comentaris:

* No, a Java no disposem de moment de *doctest*. T'atreveixes a implementar-los?

* No et preocupis per com es declaren, inicialitzen i accedeixen les seqüències
  en Java. Ja en parlarem més endavant.




Guia d'elecció del tipus de bucle
=================================

Com a resum dels quatre tipus de bucles en Java que t'he presentat, considera el
següent codi:

.. code-block:: java
    :linenos:

    /*
     * Exemple d'ús de les estructures clàsiques de bucles en Java
     */
    public class ClassicLooping {
        public static void main(String[] args) {
            String[] diesSetmana = { "dilluns", "dimarts", "dimecres", "dijous", "divendres",
                "dissabte", "diumenge" };

            int i;      // variable de recorregut compartida pels tres exemples

            // Exemple amb while
            i = 0;                                  // inicialització: primer dia
            while (i < diesSetmana.length) {        // límit: fins passarnos del darrer
                System.out.println(diesSetmana[i]); // bloc d'instruccions a repetir
                i++;                                // següent element
            }

            // Exemple amb do-while
            // Funciona perquè sabem que hi ha com a mínim un dia
            i = 0;                                  // inicialització
            do {
                System.out.println(diesSetmana[i]); // bloc a repetir
                i++;                                // següent
            } while (i < diesSetmana.length);       // límit

            // Exemple amb for
            // Resulta més compactet, però no deixa de contenir els elements bàsics
            //   inicialització            límit            següent
            //   --------------   ----------------------    -------
            for (    i = 0;       i < diesSetmana.length;     i++      ) {
                System.out.println(diesSetmana[i]); // bloc a repetir
            }


            // Exemple amb for millorat
            // No sé a tu, però a mi em sembla la versió més adequada per aquest
            // exemple!
            for ( String dia: diesSetmana ) {
                System.out.println(dia); // bloc a repetir
            }
        }
    }

Tenir on escollir sol portar el problema de saber escollir.

Escollirem un tipus de bucle o un altre, depenent de les necessitats de cada problema i, segurament,
de les nostres preferències. Et proposo la següent guia:

* ``for`` millorat: quan hem de recórrer tots els elements dins d'una seqüència des del primer al
  darrer, i no ens cal conèixer la posició en que es troba cada element.

* ``for`` "clàssic": farem servir aquest bucle quan podem calcular, a priori, quantes iteracions hem
  de realitzar; és a dir, quan hem de recórrer un rang d'elements dels que coneixem el primer,
  l'últim i quants ens saltem a cada pas. A diferència del ``for`` millorat, en aquest cas cal que
  s'acompleixi alguna de les següents condicions:

  #. Els elements no es troben dins d'una seqüència . Per exemple:

    .. code-block:: java

        // mostra les 10 primeres lletres de l'alfabet
        for (int i=0; i<10; i++) {
            System.out.println((char)('a' + i));
        }

  #. No ens calen tots els elements

     .. code-block:: java

        // mostra el nom dels dies senars i laborables de la setmana
        for (i = 0; i < 5; i+=2) {
            System.out.println(diesSetmana[i]);
        }

  #. Ens cal un ordre diferent

     .. code-block:: java

        // mostra els dies de la setmana en ordre invers
        for (i = diesSetmana.length - 1; i >= 0; i--) {
            System.out.println(diesSetmana[i]);
        }

  #. Ens cal saber en quina posició es troba cada element dins de la seqüència

    .. code-block:: java

        // mostra els dies de la setmana precedits per la seva posició
        for (i = 0; i < diesSetmana.length; i++) {
            System.out.println("(" + (i + 1) + "):" + diesSetmana[i]);
        }

* ``while``: Normalment farem servir aquest tipus de bucles per repeticions en les que no
  coneixem a priori quantes iteracions hem de realitzar. Per exemple, quan estem esperant una
  resposta concreta de l'usuari:

    .. code-block:: java

        resposta = llegeixResposta();
        while (resposta != SORTIR) {
            processaResposta(resposta);
            resposta = llegeixResposta();
        }

  Malgrat això també es pot fer amb ``for``, queda molt més clar amb ``while``.


* ``do-while``: En els casos en que aplicaríem un ``while``, però sabem que la primera iteració
  segur que es realitzarà, aquesta estructura ens pot simplificar una mica el codi:

  .. code-block:: java

        do {
            processaLinia();
        } while (calProcessarSeguentLinia());


Exercici 1. ☼ do-while en Python
================================

Tradueix el següent codi a Python:

.. code-block:: java
    :linenos:

    public class ClassicLooping {
        public static void main(String[] args) {
            String[] diesSetmana = { "dilluns", "dimarts", "dimecres", "dijous", "divendres",
                "dissabte", "diumenge" };

            int i;      // variable de recorregut compartida pels tres exemples

            // Exemple amb while
            i = 0;                                  // inicialització: primer dia
            while (i < diesSetmana.length) {        // límit: fins passarnos del darrer
                System.out.println(diesSetmana[i]); // bloc d'instruccions a repetir
                i++;                                // següent element
            }

            // Exemple amb do-while
            // Funciona perquè sabem que hi ha com a mínim un dia
            i = 0;                                  // inicialització
            do {
                System.out.println(diesSetmana[i]); // bloc a repetir
                i++;                                // següent
            } while (i < diesSetmana.length);       // límit

        }
    }

Posa especial compte en com tradueixes el ``do-while``.

Exercici 2. Entre dos nombres
=============================

Recordes l'exercici :ref:`entre dos nombres<exercici_entre_dos_nombres_python>`?

Desenvolupa en Java un programa que demani dos nombres enters i mostri tots els
nombres començant pel primer i acabant pel segon.

Simulació:

.. code-block:: none

    $ java EntreDosNombres
    Primer?
    3
    Segon?
    6
    3 4 5 6

    $ java EntreDosNombres
    Primer?
    6
    Segon?
    3
    6 5 4 3

    $ java EntreDosNombres
    Primer?
    -4
    Segon?
    3
    -4 -3 -2 -1 0 1 2 3

    $ java EntreDosNombres
    Primer?
    4
    Segon?
    4
    4

Exercici 3. Històric d'edats en Java
====================================

Rescata el problema que vas realitzar a :ref:`Històric d'edats
<exercici_historic_edats_python>` i converteix-lo a Java.

Pots fer servir els :download:`mateixos fitxers de
prova<_recursos/suport11.1.2.6.historicedats.tar.gz>` de la versió en Python i,
per automatitzar la prova, utilitza :download:`test_java.sh
<_recursos/test_java.sh>`.


Exercici 4. El lloro en Java
============================

Rescata l'exercici :ref:`El lloro <exercici_lloro_python>` que vas fer en Python
i converteix-lo a Java.

Exercici 5. Lletra continguda
=============================

Rescata l'exercici :ref:`Lletra continguda <exercici_lletra_continguda_python>` que vas fer en Python i
tradueix-lo a Java.

**Nota**: no es permés l'ús de les funcions de strings  ``boolean contains()``
ni  ``int indexOf()`` ni cap altra d'aquesta familia. Si tens dubtes simplement
pregunta't *la funció m'estalvia fer un bucle?*. Si la resposta és *sí*, llavors
la funció probablement està prohibida ;) (``int length()`` sí que pots, eh?)

Exercici 6. Paraula continguda
==============================

Rescata l'exercici :ref:`Paraula continguda
<exercici_paraula_continguda_python>` que vas fer en Python i tradueix-lo a
Java.

**Nota**: no es permés l'ús de les funcions de strings  ``boolean contains()``
ni  ``int indexOf()`` ni cap altra d'aquesta familia. Si tens dubtes simplement
pregunta't *la funció m'estalvia fer un bucle?*. Si la resposta és *sí*, llavors
la funció probablement està prohibida ;) (``int length()`` sí que pots, eh?)

Exercici 7. ☼ Més programes de bucles
=====================================

Disposes d'un bon grapat de programes a :doc:`recorreguts.numerics.python` i
doc:`while.juguem` que vas desenvolupar amb Python i que no apareixen entre els
exercicis anteriors. Molts fan servir *doctest* i, per tant, funcions
que encara no hem vist.

Si estàs impacient per provar els bucles en Java, et proposo que comencis a
traduir aquests programes, de moment sense funcions, tot
recollint els valors de l'entrada estàndard i deixant els resultats a la sortida
estàndard.

----

Anotacions
==========

.. [#enumerate] Considera la funció ``enumerate()`` en Python. Per exemple:

    .. code-block:: python

        >>> sequencia = ('hola', 'i', 'adéu')
        >>> for index, paraula in enumerate(sequencia):
        ...     print('index: %s parula: %s' % (index, paraula))
        ...
        index: 0 parula: hola
        index: 1 parula: i
        index: 2 parula: adéu
        >>> tuple(enumerate(sequencia))
        ((0, 'hola'), (1, 'i'), (2, 'adéu'))

----

*Ref. IP17.9*
