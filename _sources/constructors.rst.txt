############
Constructors
############

Coneixerem ara els *constructors*, un tipus especial de bloc de codi que
en programació orientada a objectes és cridat la creació d'una nova
instància d'una classe, i que té la funció de preparar la instància per a
ser utilitzada.

Aquesta introducció comença amb una secció *teòrica* que descriu els
constructors (i destructors), per després continuar amb l'anàlisi
d'exercicis en Java.

.. warning::

    La secció teòrica pot resultar molt complexa per qui mai no ha estat exposat a la gestió
    explícita de memòria dinàmica. Si és el teu cas, intenta aproximar-te-hi amb ment oberta.

Però si ja els coneixem!
========================

En realitat ja hem fet servir els constructors. En el tema :doc:`classes_i_objectes` hem vist codi que
fa:

.. code-block:: java
    :linenos:
    :emphasize-lines: 5

    public class GatRenat {
        int vides = 7;                // vides disponibles del gat Renat
        public static void main(String[] args) {
            GatRenat renat;           // declarem la referència al gat
            renat = new GatRenat();   // creem la instància del gat Renat.
            System.out.println("Al gat Renat li queden " + renat.vides + " vides");
        }
    }


A la línia 5 estem creant o *construint* una instància de *GatRenat*. Un cop executada, sabem que
la referència *renat* queda inicialitzada a un valor de tipus *GatRenat*.

D'acord, però… què és el que realment està passant quan cridem al constructor d'una classe?


.. _constructors_i_destructors:

Constructors i destructors
==========================

Un aspecte important, pels programes en execució, és la reserva i
posterior alliberament de memòria necessària per a poder fer encabir
dinàmicament les dades que manipulen.

Considerem per exemple, la implementació d'una *llista dinàmica* d'enllaç simple,
sovint es realitza amb una estructura (Node) que conté almenys dos
camps (el valor a guardar per un element de la llista i un apuntador
al següent node). Normalment ens cal disposar d'un apuntador al primer
node, i el darrer node apunta convenientment a un valor nul.

La següent imatge esquematitza una llista d'aquestes amb dos elements.

.. figure:: _images/poo008.img001.llistadin_doselem.png
    :alt: Dos elements
    :align: center

En cas que hi vulguem afegir un nou node, ens cal realitzar les
següents passes:

#. **reservar** l'espai pel nou node

#. **inicialitzar** els valors del nou node. Com a mínim l'apuntador a
   següent node, que farem apuntar al node que correspongui de la
   llista, o bé a *null* si ha de ser el nou darrer.

#. reassignar l'apuntador del node de la llista que ha de ser anterior
   al nou node, per què tingui com a següent el nou node.

El resultat final queda representat per la següent imatge:

.. figure:: _images/poo008.img002.llistadin_treselem.png
    :alt: Tres elements
    :align: center

Per una altra banda, quan volem eliminar un element de la llista, les
passes que hem de fer són:

#. fer que el punter a següent node del node anterior al que volem
   eliminar, passi a apuntar al node següent del node que volem
   eliminar.

#. **alliberar** l'espai ocupat pel node a eliminar.

El resultat final queda:

.. figure:: _images/poo008.img003.llistadin_menyselem.png
    :alt: Menys elements
    :align: center

De les operacions vistes en aquest exemple, podem dir que tot node de
la llista ha de ser:

#. **creat**: *reserva de memòria* per a allotjar-lo i *inicialització*

#. **destruït**: *alliberament* de la memòria reservada un cop sabem
   que no ens cal tornar a fer-lo servir.

En Java, la creació d'una nova instància la realitzem mitjançant
l'expressió ``new «Constructor»(«args»)`` on «Constructor» coincideix
amb el nom de la classe i «args» corresponen als valors
d'inicialització (sovint no hi ha cap).

La destrucció en Java **no** es realitza explícitament (a diferència
d'altres llenguatges OO com ara C++)

Java (com molts altres llenguatges OO) disposen d'un procés de baixa
prioritat anomenat *recolector d'escombraries* (*Garbage Collector*)
que se n'encarrega d'anar alliberant aquells espais de memòria que ja
no estan referenciats per ningú. El llenguatge no ens ofereix manera
d'influenciar a aquest procés.

En tot cas **sí** podem ajudar al *Garbage Collector*. Si disposem
d'una instància que ocupa **molta** memòria i sabem que ja no la
necessitem més al nostre programa, sempre podem assignar totes les
seves referències a ``null``. D'aquesta manera, el *Garbage Collector*
sabrà de seguida que ja no cal i podrà actuar en conseqüència.
Considera el següent exemple:

.. code-block:: java
    :linenos:

    // «…»
    ClasseGrossa cg = new ClasseGrossa(); // instància que ocupa molt
    // «…»        // usem la instància tot el que la necessitem
    cg = null;      // eliminem la referència a la instància


Exercici 12. Construcció del gat Renat
======================================

Considera el següent codi:

.. code-block:: java
    :linenos:

    public class GatRenat {
        private int vides;   // vides disponibles del gat Renat

        // constructor per defecte
        public GatRenat() { vides = 7; }

        // constructor específic
        public GatRenat(int vides) {
            if (vides >= 0) {
                this.vides = vides;
            } else {
                this.vides = 7;
            }
        }

        public int getVides() { return vides; }

        // canvia el nombre de vides si el nou valor és vàlid
        public void setVides(int vides) {
            if (vides >= 0) {
                this.vides = vides;
            }
        }

        public static void main(String[] args) {
            GatRenat renat = new GatRenat();
            System.out.println("Al Renat li queden " + renat.getVides() + " vides");
            GatRenat megaRenat = new GatRenat(12);
            System.out.println("A Mega Renat li queden " + megaRenat.getVides() + " vides");
        }
    }

Executa el programa i respon a les següents preguntes:

1. A quina línia es posa el valor de vides de la instància creada a la 26?

2. A quina línia es posa el valor de vides de la instància creada a la 28?

3. Els blocs que s'inicien a les línies 5 i 8 semblen mètodes però hi
   ha algunes diferències amb un mètode convencional. Quines són?

4. Què et suggereixen els comentaris de les línies 4 i 7?

5. Quan s'executa el codi dels blocs iniciats a les línies 5 i 8.

6. Elimina o comenta la línia 5. Continua funcionant el codi? Perquè
   creus?

7. Substitueix el codi del bloc de la línia 8 pel següent i descriu
   què passa a l'hora d'executar:

   .. code-block:: java
       :linenos:

       // constructor específic
       public GatRenat(int vides) {
           this();
           setVides(vides);     // o també this.setVides(vides);
       }

8. Per a què creus que serveix el ``this()``?

   Pista: fes escriure un missatge per sortida estàndard al constructor
   per defecte i compara que passa en executar el codi quan ``this()`` hi
   és, i quan el treus.

Exercici 13. ☞ El gat Renat pot no néixer estirat
=================================================

Crea una nova versió de la classe GatRenat a partir de com va quedar a :ref:`l'últim exercici
<classes_i_objectes_exercici10>`.

En aquesta ocasió, la classe ``GatRenat`` permetrà ser inicialitzada tot
indicant amb quin estat (estirat, assegut o dret)

Cal assegurar-se que codi que ja funcionava amb la versió anterior,
continuï fent-ho amb aquesta.

Per defecte, el gat Renat *naixerà* estirat com fins ara, a menys que es
faci servir el nou constructor.

.. _constructors_i_exercici_entorn_operatiu:

Exercici 14. ☞ L’entorn operatiu del gat Renat
==============================================

En aquesta ocasió desenvoluparem un programa que oferirà la possibilitat d'interaccionar amb el gat
Renat amb una interfície de línia de comandes.

El programa mostrarà com a "prompt" ``[Renat]:``

Les comandes que se li podran donar seran:

.. code-block:: none

    com estàs?
    aixeca’t
    seu
    estira’t
    adéu

L'entorn no distingirà entre majúscules i minúscules. En cas que no entengui la comanda, l'entorn
contestarà amb el missatge ``no t'entenc`` i continuarà demanant noves comandes.

Inicialment el gat Renat tindrà 7 vides i estarà **dret**.

Quan es demani a l'entorn com està el gat Renat, l'entorn li ho demanarà al gat (fent servir el
mètode ``GatRenat.getEstatComString()``) i mostrarà la resposta que retorni el gat amb el misatge
``estic «estat»``. Per exemple, si el gat respon ``estirat``, la resposta de l'entorn serà ``estic
estirat``. El següent diagrama mostra la seqüència d'intercanvis entre els diferents actors
d'aquesta interacció.

.. uml::

    @startuml
        actor usuari
        usuari -> entorn: com estàs?
        entorn -> renat: getEstatComString()
        renat --> entorn: "estirat"
        entorn --> usuari: "estic estirat"

        skinparam sequence {
            ParticipantBackgroundColor white
            ActorBackgroundColor white
        }
    @enduml

Quan se li digui ``adéu``, respondrà amb ``adéu`` i finalitzarà.

Per la resta de comandes, el programa respondrà amb el que respongui el gat.

Per facilitar la prova d'aquest programa, caldrà que respecti algunes condicions addicionals.
Crea una nova classe anomenada ``EntornOperatiu`` que ofereixi:

* dos constructors. Un constructor per defecte que crearà la seva pròpia instància de ``GatRenat`` i
  un altre d'específic que rebrà la instància de ``GatRenat`` amb la que treballarà l'entorn.

  **Atenció**: el constructor **no** farà una còpia de la instància rebuda, sinó que la farà servir
  directament. Tot i que, en general, aquesta no és una manera recomanable de programar, en aquesta
  situació concreta ens simplifica molt l'exercici.

  En ambdós casos, la instància del gat haurà de respectar els requeriments d'inici ja esmentats.

* un mètode anomenat ``String processaEntrada(String entrada)`` que rebrà la comanda d'entrada i
  retornarà el text que s'haurà de mostrar com a resposta.

* un mètode anomenat ``boolean demanaSortir(String entrada)`` que retornarà ``true`` quan l'entrada
  correspongui al text de sortida (en aquest cas *adéu*.

Crea un mètode ``main()`` que creï un ``EntornOperatiu`` i llegeixi comandes de l'entrada estàndard,
les processi amb ``processaEntrada()`` i mostri el resultat retornat fins que l'usuari demani la
sortida.

Crea un joc de proves que permeti comprovar el funcionament de cadascuna de les opcions. El joc de
proves estarà format per dos fitxers, un amb les comandes d'entrada i un amb la sortida esperada.

El d'entrada començarà amb:

.. code-block:: none

    com estàs?
    seu
    «…»

El de sortida començarà amb:

.. code-block:: none

    [Renat] estic dret
    [Renat] m'assec
    [Renat] «…»

Nota: en cas que ens descuidem de finalitzar al fitxer d'entrada amb "adéu", és molt probable que
ens surti un error d'execució del tipus ``java.lang.NullPointerException``. El problema és que la
lectura de l'entrada estàndard ens retorna ``null`` en comptes d'un String buit.  Caldrà només
continuar quan llegim res que no sigui null. És clar, si arribem a null finalitzarem l'execució però
no ens acomiadarem de l'usuari. Faltaria més!

.. _constructors_i_exercici_classe_hora:

Exercici 15. ☞ La classe Hora
=============================

Implementa la classe Hora amb les propietats (privades) hora, minut i
segon de tipus enter, i els accessors (públics) que assegurin que
l'hora és sempre vàlida.

Per defecte, l'hora correspondrà a ``0:00:00``, però la classe oferirà els mecanismes necessaris per
a inicialitzar una hora amb algun altre valor *vàlid*. És a dir, oferirà un constructor específic
amb la signatura ``Hora(int hores, int minuts, int segons)`` que, en cas de que els valors rebuts no
corresponguin amb una hora vàlida, inicialitzarà l'hora amb el valor per defecte.

Afegeix els següents mètodes:

* ``void incrementa()``: fa que l'hora tingui un segon més

* ``void incrementa(int)``: fa que l'hora s'incrementi en el nombre de segons indicats

* ``void decrementa()``: fa que l'hora tingui un segon menys

* ``void decrementa(int)``: fa que l'hora es decrementi en el nombre de segons indicats

* ``int compareTo(Hora)``: compara amb l'hora indicada i retorna <0 si és menor que la indicada, 0 si són iguals i >0 si és més gran que la indicada.

* ``String toString()``: retorna un String amb l'hora en format h:mm:ss.

Desenvolupa una funció ``main()`` que demani a l'usuari les dades de
tres hores i, fent servir la classe Hora, les mostri ordenades
creixentment.

**Notes / pistes**

#. En cas que un constructor específic es trobi amb un o més
   paràmetres no vàlids, inicialitzarà la instància amb els valors per
   defecte.

#. Per escriure el 0 inicial als minuts i segons quan el valor és menor de
   10, es pot fer servir el mètode `System.out.format()
   <https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Formatter.html>`_


Exercici 16. Què he aprés dels constructors?
============================================

Fes un repàs dels continguts d'aquest tema incloent els exercicis anteriors.
Indica exercici a exercici què has aprés de nou en fer-lo, o bé quins són els
conceptes que introdueix l'exercici, si ja els coneixies anteriorment. Procura
ser molt concret. Si et cal, ajuda't de (nous) exemples.

En el cas que no hagis entès algun dels exercicis… bé, aquest cas no es pot
donar ja que, abans de fer aquest exercici t'ajudaràs de les diferents fonts de
suport que tens al teu abast (incloent, és clar, consultes al teu docent) per
arribar a entendre'l. És a dir, **no val** dir, que un exercici no l'has entès!
Entesos?

Redacta aquest exercici en un document de text pla. Et recomano que facis servir
algun format de text de marques com ara :doc:`reStructuredText <rst.intro>`
o `markdown
<https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet>`_.

