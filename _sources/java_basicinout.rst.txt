##########################
Entrada i sortida bàsiques
##########################

En aquesta secció aprendrem a accedir als canals d'entrada i sortida
estàndards que el sistema operatiu típicament ofereix a tot procés.

Hi ha moltes possibilitats per fer aquesta comunicació. Per exemple, els
nostres programes podrien rebre les dades d'un fitxer, d'un servidor
connectat a la xarxa, o d'algun dispositiu com ara un ratolí. Per altra
banda, podrien deixar els resultats en un altre fitxer, o comunicar-los a
un altre programa com ara un navegador d'Internet.

Especialment en programes més bàsics, sovint ens comuniquem amb mitjançant
una pantalla i un teclat.  En començar a funcionar el nostre programa, es
trobarà generalment que el teclat està connectat a un canal anomenat *canal
d'entrada estàndard*, mentre que la pantalla estarà connectada a dos
canals *canal de sortida estàndard* i *canal de sortida estàndard
d'error*.

En aquesta secció veurem algunes maneres d'escriure per sortida estàndard
i de llegir de l'entrada estàndard.

.. important:: No et deixis desanimar amb la comparació amb Python. Recorda que
    el disseny dels dos llenguatges i, sovint, els seus objectius, són molt
    diferents.

Sortida estàndard
=================

La sortida estàndard, normalment dirigida cap a la pantalla del nostre
equip. Podria, però, estar *redirigida* cap algun altre lloc, com ara un
fitxer. Per exemple, recordem el nostre programa:

.. code-block:: java
    :linenos:
    :emphasize-lines: 6

    /*
     * Programa que saluda al món
     */
    public class HolaMon {
        public static void main(String[] args) {
            System.out.println("Hola Món!");
        }
    }


La seva execució podria haver estat invocada de la següent manera:

.. code-block:: none

    $ java HolaMon > sortida.txt
    $ cat sortida.txt
    Hola Món!

Així, podríem emmagatzemar el resultat del nostre programa a un fitxer.

Analitzem amb detall la instrucció ``System.out.println("Hola Món!");``

* ``System``: agrupa diferents utilitats i valors del sistema en que
  funciona el nostre programa

* ``out``: fa referència a la sortida estàndard. ``System`` ofereix també
  ``in`` per l'entrada estàndard i ``err`` per la sortida estàndard
  d'error.

* ``println()`` és el nom de la funció que estem cridant. La sortida
  estàndard ``out`` (i també ``err``) és de tipus `PrintStream
  <http://docs.oracle.com/javase/8/docs/api/java/io/PrintStream.html>`_ i
  ofereix, entre d'altres funcions, aquesta ``println()`` que escriu
  l'argument que se li passa (potser cap) i finalitza amb un salt de
  línia.

* ``"Hola Món!"``: és l'argument que passem a ``println()``. Serà el
  missatge que escriurà per sortida estàndard.

  ``out`` ofereix altres funcions. Per exemple, considera el següent
  exemple:

  .. code-block:: java
    :linenos:

        /*
         * Demostració d'ús de diferents formes d'escriure per sortida estàndard
         */
        public class HolaMonPrintAlternatius {
            public static void main(String[] args) {
                System.out.println("Hola Món!");        // el "clàssic"
                System.out.print("Hola Món!\n");        // explicitant el salt de línia
                System.out.printf("%s%n", "Hola Món!"); // amb sortida formatada
            }
        }


  Fixat que ``print()`` i ``printf()`` requereixen explicitar el salt de línia.

``printf()`` és semblant a la funció ``print()`` de Python. Permet definir un
patró en forma de String amb variables (que comencen amb ``%``) que després
substituirà amb els valors que rep a continuació.  En el cas de l'exemple,
apareix ``%s`` i ``%n``, el primer indica que rebrà un valor de tipus String (el
literal ``"Hola Món!"`` mentre que el segon seria equivalent a ``\n`` però és
vàlid per més plataformes, i per tant, recomanat. A banda d'aquestes opcions,
permet indicar altres tipus de dades. Considera el següent exemple:

.. literalinclude:: _code/DemoPrintf.java
    :language: java

En executar el programa anterior, obtenim:

.. code-block:: none

    $ javac DemoPrintf.java  && java DemoPrintf
    Un enter 42 i un decimal 3.1416 concatenant
    Un enter 42 i un decimal 3,141600 fent servir printf()
    El mateix 3,141600 ara amb tres decimals 3,142

Com veus a l'exemple, podem tenir molt més control en el formatat de la nostra
sortida amb ``printf()`` que amb ``println()``.  Entre d'altres coses, ens ha
posat una coma en comptes d'un punt, per indicar els decimals. És a dir,
s'adapta a com es mostra en l'idioma en que està configurat el nostre sistema!
També ens permet fàcilment controlar el nombre de decimals que volem que es
mostrin. En aquest cas li hem demanat que apareguin 3 decimals amb ``%.3f``.

La funció ``printf()`` està molt relacionada amb ``String.format()`` de la
que ja :ref:`hem parlat <java_construccio_strings>`. Els següénts exemples
generarien la mateixa sortida:

.. code-block:: java

    System.out.printf("Tinc %d anys%n", 19);
    System.out.print(String.format("Tinc %d anys%n", 19));
    System.out.println(String.format("Tinc %d anys", 19));


Trobaràs tot el detall sobre els elements que poden aparèixer dins del patró de
``printf()`` a la secció `Format String Syntax
<http://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax>`_.


Entrada estàndard
=================

Java no és el llenguatge més senzill a l'hora de fer programes amb entrada per
consola. Una de les maneres més fàcils és fer servir `java.util.Scanner
<http://docs.oracle.com/javase/8/docs/api/java/util/Scanner.html>`_.

Un exemple senzillet d'ús el mostra el següent programa:

.. code-block:: java
    :linenos:

    import java.util.Scanner;
    public class DemoScanner {
        public static void main(String[] args) {
            Scanner entrada = new Scanner(System.in);   // declaració de la nostra entrada

            System.out.print("Com et dius?: ");
            String nom = entrada.next();

            System.out.printf("Quants anys tens %s: ", nom);
            int edat = entrada.nextInt();

            System.out.printf("Dius que tens %d anys %s? Se't veu molt bé!%n", edat, nom);
        }
    }

.. note:: La línia ``import`` ens serveix basicament per poder escriure dins del
          codi ``Scanner`` en comptes de ``java.util.Scanner``.

Un cop has realitzat la declaració de la variable Scanner (línia 4), simplement has de fer
``entrada.next()`` per llegir un String o ``entrada.nextInt()`` per llegir un enter. Hi ha altres
utilitats (com ara ``nextDouble()``) per a poder llegir valors dels diferents tipus primitius.

En tot cas, cal que tinguis present que aquest ús de ``Scanner`` farà finalitzar el nostre programa
en cas que l'usuari no ens introdueixi un valor del tipus esperat.
A més a més, no ens permetrà llegir respostes buides (només <ENTER>)

Una altra manera de llegir per entrada estàndard que ens requerirà una
mica més de codi però ens solucionarà aquests problemes és:

.. code-block:: java
    :linenos:

    import java.io.BufferedReader;
    import java.io.InputStreamReader;
    import java.io.IOException;
    public class DemoReader {
        public static void main(String[] args) throws IOException {
            BufferedReader entrada = new BufferedReader(new InputStreamReader(System.in));
            String text = entrada.readLine();       // llegim una línia de text
            int enter = Integer.parseInt(text);     // convertim el llegit a enter
            // …
        }
    }

Fixa't que aquesta solució ens està obligant a escriure ``throws
IOException`` al costat de la signatura del ``main()``. Es tracta d'un
mecanisme de Java per controlar possibles errors. En parlarem més
endavant.

Donat que normalment ens interessarà disposar d'una única variable
``entrada``, pot ser còmode expressar el programa anterior de la següent
manera:

.. code-block:: java
    :linenos:

    import java.io.BufferedReader;
    import java.io.InputStreamReader;
    import java.io.IOException;
    public class DemoReader {
        static BufferedReader entrada = new BufferedReader(new InputStreamReader(System.in));
        public static void main(String[] args) throws IOException {
            String text = entrada.readLine();       // llegim una línia de text
            int enter = Integer.parseInt(text);     // convertim el llegit a enter
            // …
        }
    }

Fixa't que la declaració i inicialització de la variable ``entrada``
apareix ara fora de ``main()``. Això tindrà més sentit quan treballem amb
més mòduls, en breu.

Quin mètode faig servir?
========================

Disposant de dos maneres de fer quelcom similar, apareix la necessitat de
decidir. Sense entrar en temes d'eficiència, et recomanaré que, a l'hora
de realitzar els exercicis, consideris fer servir ``Scanner`` si
l'exercici "es deixa". És a dir, si passa les proves. Altrament, et tocarà
fer la transformació. El cert és que, un cop te n'acostumes, la solució
amb el ``reader`` tampoc no és tan traumàtica.

Pensa que la majoria dels programes professionals que desenvoluparàs en
Java, molt probablement no accediran a l'entrada/sortida estàndard, sinó
que es comunicaran amb coses més sofisticades com ara formularis, fitxers,
BDs, sockets, … on la complexitat dels *readers* la trobaràs totalment
justificada.


.. _exercici_calculadorabasica_java:

Exercici 9. ☞ La calculadora bàsica en Java
===========================================

Recordes l'exercici de la :ref:`calculadora bàsica
<exercici_calculadorabasica_python>` que vas fer en Python?  Doncs ara toca
fer-ho en Java.

Et recordo l'enunciat:

Desenvolupa una calculadora bàsica que demani a l'usuari dos operands i
mostri el resultat de realitzar les operacions bàsiques (+ - * /) sobre
els operands.

Exemple d'interacció:

.. code-block:: none

    $ java CalculadoraBasica
    Primer operand?
    6
    Segon operand?
    2
    6,00 + 2,00 = 8,00
    6,00 - 2,00 = 4,00
    6,00 * 2,00 = 12,00
    6,00 / 2,00 = 3,00

Pistes:

* Com que Java requereix més precisió que Python a l'hora d'indicar els tipus de
  dades, pots suposar que les dades d'entrada són *double*.

* No et preocupis si alguna operació no és vàlida pels valors introduïts.
  En tot cas, potser et resulta curiós veure quin resultat ofereix Java
  quan hi ha divisió per 0.

* Per mostrar només 2 decimals, considera el següent codi:

  .. code-block:: java

    System.out.printf("%f", 4.3)      // escriu 4,300000
    System.out.printf("%.2f", 4.3)    // escriu 4,30

