######################
Coneixem els *doctest*
######################

Fins ara, en escriure els nostres programes hem definit una simulació de com han
de ser executats. Això ens ha permès prendre decisions com ara el nom del
programa i el text dels missatges a intercanviar amb els usuaris.

A banda, en alguns exercicis el docent ens ha *regalat* uns programes que de
manera més o menys màgica ens diuen si hem fet bé o no els nostres exercicis.

Hi hauria alguna manera d'aconseguir no dependre d'un programa extern per
comprovar que els nostres programes funcionen i, evidentment, sense que hàgim de
fer les proves manualment?

Considera novament el programa ``saludausuari.py``:

.. literalinclude:: _code/saludausuari.py
    :language: python
    :linenos:

Una nova versió
===============

Considera la següent modificació del programa:

.. literalinclude:: _code/saludausuaridef.py
    :language: python
    :linenos:
    :emphasize-lines: 10-16, 24


En aquesta nova versió del nostre saludador d'usuaris, tenim unes quantes modificacions importants:

* línia 24: en comptes de composar el missatge, assignem a ``missatge``
  l'expressió ``saluda_usuari(nom)``

  Aquesta expressió és una *crida a una funció* anomenada ``saluda_usuari()``
  que estem definint a la línia 10.

* línia 10: és la definició d'una funció

  De moment, una *funció* és un codi al que li donem un nom i les dades que
  necessita per realitzar el seu càlcul.

  En aquest cas, hem escollit ``saluda_usuari`` com a nom de la funció, doncs és
  el nom del programa.

  La funció ``saluda_usuari()`` necessita la variable ``nom`` per composar el
  missatge. Per aquesta raó ``nom`` apareix tant a la línia 10 com a la 24.

* línia 16: aquest és el punt en que la funció *retorna* el resultat de la
  composició. Ho podem entendre com que la funció *informa* al compilador que la
  variable ``resultat`` conté el missatge resultant.

* línies 11 a 14: es tracta d'un comentari que documenta la funció
  ``saluda_usuari()``.

* línies 11 a 16: aquest és el *cos* de la funció. Per indicar que tot forma
  part de la funció, fixat que totes les línies estan indentades.

* línies 12 i 13: es tracta d'una simulació d'execució. En aquest cas el que
  estem simulant, en comptes de ser una execució de tot el programa, ho és només
  de la funció ``saluda_usuari()``

  Fixa't que a la línia 12 apareix el *prompt* de la consola de Python. Fixa't
  també que a la línia 13, el resultat apareix entre cometes, doncs és com
  representa Python els strings.

  A aquestes simulacions se les anomena *doctest* o *proves dins de comentari*.

* línia 18: és una condició que indica a Python que només executi el que ve a
  continuació només quan el programa és executat com a ``python3
  saludausuari.py``. De moment, creu-t'ho.

* linies 19 a 21: obtenció del valor d'entrada. Fixa't que és el mateix codi que
  al programa original.

* línia 24: en comptes de composar el missatge de sortida com a la línia 15 del
  programa original, ara fem que la *funció* ``saluda_usuari()`` composi aquest
  resultat per nosaltres.

* la resta de línies corresponen a les del programa original, només que
  indentades dins del condicional de la línia 18.

Si tornem a executar ``saludausuari.py`` trobarem que fa el mateix que l'antiga
versió.

Comprovem la funció a la consola de Python
==========================================

Podem passar aquest codi a la consola de Python i fer la prova de la funció per nosaltres mateixos.
Per exemple, entra en la consola i escriu el següent:

.. code-block:: python
    :linenos:

    >>> def saluda_nom(nom):
    ...     """ composa el missatge de salutació a partir del nom i el retorna.
    ...     >>> saluda_usuari('Manel')
    ...     "Hola Manel. M'encanta saber de tu"
    ...     """
    ...     resultat = "Hola " + nom + ". M'encanta saber de tu"
    ...     return resultat
    ...
    >>> saluda_nom('Manel')
    "Hola Manel. M'encanta saber de tu"
    >>> help(saluda_nom)
    Help on function saluda_nom in module __main__:

    saluda_nom(nom)
        composa el missatge de salutació a partir del nom i el retorna.
    (END)

A les línies entre la 2 i la 7, després dels puntets que t'afegeix la consola,
hauràs d'escriure uns espais inicials per indentar-les.

Per indicar a la consola de Python que ja has finalitzat la definició de la funció, caldrà que facis
un salt de línia en blanc (línia 8)

A la línia 9 estem *cridant* la funció, tot passant-li el nom de l'usuari a
saludar. La línia 7 ens la genera Python com a resultat de la crida. És el que
esperàvem, no?

Finalment, a la línia 14, i només com a curiositat de moment, podem veure que en
fa Python de la documentació de la nostra funció. Si li demanem que ens ofereixi
ajuda (*help*) sobre la funció, l'intèrpret ens mostra la documentació que li
hem proporcionat.

Comprovem *doctest* automàticament
==================================

De moment no sembla que hàgim aconseguit millorar gaire, oi? De fet, el codi
resultant és molt més llarg que l'original.

Veiem si et puc convèncer de que val la pena el canvi.

Python ens ofereix una manera de comprovar que el test de la funció és correcte.

.. code-block:: none
    :linenos:
    :emphasize-lines: 1-6, 13

    $ python3 -m doctest -v saludausuaridef.py 
    Trying:
        saluda_usuari('Manel')
    Expecting:
        "Hola Manel. M'encanta saber de tu"
    ok
    1 items had no tests:
        saludausuaridef
    1 items passed all tests:
       1 tests in saludausuaridef.saluda_usuari
    1 tests in 2 items.
    1 passed and 0 failed.
    Test passed.

Fixa't que estem cridant el programa ``python`` amb arguments. En concret, ``-m
doctest``. Aquest argument faran que Python comprovi els *doctest* que
contingui el programa. Per altra banda ``-v`` farà que Python ens ofereixi un
munt d'informació respecte les proves que realitzi.

T'ho tradueixo al català per la teva comoditat:

* Línies 2 a 5: Estic intentant executar la prova de cridar la funció ``saluda_usuari('Manel')`` i
  espero que el seu resultat sigui ``"Hola Manel. M'encanta saber de tu"``.

* Línia 6: He trobat el que esperava.

* Línia 13: S'han superat totes les proves

És a dir, que tot ha anat bé!

Podem afegir més d'un ``doctest`` a una funció. Per exemple:

.. code-block:: python

    def saluda_usuari(nom):
        """ composa el missatge de salutació a partir del nom i el retorna.
            >>> saluda_usuari('Manel')
            "Hola Manel. M'encanta saber de tu"
            >>> saluda_usuari('Anna')
            "Hola Anna. M'encanta saber de tu"
        """
        resultat = "Hola " + nom + ". M'encanta saber de tu"
        return resultat

En aquest cas, en executar-ho amb ``-m doctest`` ens informarà que han estat dues les proves que
s'han realitzat.

Ara bé un altre avantatge: per provar la nostra funció **no cal** que escrivim
el codi necessari per obtenir els valors dels usuaris. Ja sabem que som capaços
de fer ``print()`` i ``input()`` i el que ens preocupa és solucionar el problema
que tenim davant nostre.

Així, el nostre programa ``saludausuari.py`` es podria quedar de la següent
manera:

.. code-block:: python
    :linenos:

    # Funció que donat el nom d'un usuari composa una salutació.

    def saluda_usuari(nom):
        """ composa el missatge de salutació a partir del nom i el retorna.
            >>> saluda_usuari('Manel')
            "Hola Manel. M'encanta saber de tu"
        """
        resultat = "Hola " + nom + ". M'encanta saber de tu"
        return resultat


En resum
========

Què hem fet?

* hem extret la part del codi del nostre programa que realitzava els càlculs i
  l'hem substituïda per la crida a una funció

* hem definit la funció amb el nom del nostre programa

* hem posat, entre parèntesis, els valors (o arguments) necessaris perquè la
  nostra funció pugui fer el que ha de fer

* hem documentat la funció, tot explicant què fa, què retorna i de quin tipus
  espera els seus arguments

* hem afegit uns comentaris especials, anomenats ``doctest`` que simulen
  l'execució de la funció a la consola de Python

* hem afegit el codi antic dins del bloc de la funció (indentat)

* hem finalitzat amb ``return`` a la nostra funció per indicar quin és el
  resultat de cridar-la.

* hem comprovat l'execució de la funció a la consola de Python

* hem substituït el codi original per una crida a la funció, tot passant-li els
  valors que requereix per fer el càlcul, amb el tipus adequat

* hem ficat el codi original (amb la crida a la nova funció) dins d'un bloc d'un
  condicional especial.

* hem provat que el codi canviat continua passant les proves que ja teníem

* hem fet que Python comprovi automàticament la simulació de l'execució de la
  funció, amb els arguments ``-m doctest -v``

Hem fet moltes coses, oi? Ens caldrà una mica d'entrenament per tal de pair-les.

Practiquem
==========

Les següents pràctiques et permetran entendre una mica millor la
transformació que hem fet aquí.  Caldrà que tornis a revisar el codi de
vàries pràctiques anteriors.

Com que en alguns exercicis treballarem sobre el codi ja desenvolupat
d'exercicis previs, et recomano que facis una còpia de tot el contingut.

Et recordo la comanda:

.. code-block:: bash

    $ cp -vr carpeta_inicial carpeta_final

Fixa't l'argument ``-r`` que permet copiar també el contingut de
subcarpetes (com ara ``test/``)

Fixa't també que mantindrem els fitxers de prova que ja teníem. Això ens
permetrà comprovar que no hem trencat res amb els canvis.

Exercici 7. El quadrat d'un número (reloaded)
=============================================

Recordes l'exercici :ref:`exercici_quadratnum`? Doncs toca fer una nova
versió.

Crea la carpeta ``02_07_quadratnumero/`` i còpia-hi el contingut de
``01_07_quadratnumero/``. Per exemple:

.. code-block:: bash

    $ cp -vr 01_07_quadratnumero 02_07_quadratnumero

Ara, edita ``02_07_quadratnumero/quadratnum.py`` i modifica'l segons els canvis
vistos en aquesta secció.

Segueix, a mode de recordatori, les següents instruccions:

#. Defineix la funció que tindrà el codi que calcula i composa el missatge a
   partir de l'entrada.

   .. code-block:: python

        def quadrat_num(num):

#. Documenta la funció (què fa?)

   Recorda, fes servir ``"""`` a partir de la següent línia de la definició del
   nom de la funció.

#. Simula una execució com a ``doctest``

   Per la simulació pots fer servir la prova que es fa a la simulació del
   programa sencer:

   .. code-block:: python

        >>> quadrat_num(4)
        'El quadrat de 4 és 16'

   Fixa't que la simulació rep un ``4`` i no un ``'4'``!

#. Posa dins del bloc de la funció el codi que en la versió anterior calculava
   el quadrat del número feia la composició del missatge.

   En comptes d'escriure el resultat amb ``print()``, guarda'l a una variable
   anomenada, per exemple, ``resultat``.

#. Retorna el resultat composat (amb ``return``)

#. Modifica la part antiga que composava el missatge, de manera que ara cridi la
   funció que acabes de definir.

   Atenció: la funció ``quadrat_num()`` espera un número, així que hauràs de
   convertir el valor que hagis recollit de ``input()`` abans de passar-li.

   No oblidis ficar-ho tot dins de la condició ``__name__ == '__main__'``.

#. Passa les proves antigues (``$ bash test/test.sh``)

#. Passa les proves de ``doctest``:

   .. code-block:: none

        $ python3 -m doctest -v quadratnum.py

.. important:: Assegura't que aconsegueixes que funcioni aquest exercici i
    entendre bé el que has fet, abans de passar al següent.


Exercici 8. La meitat d'un número (re-loaded)
=============================================

Copia l'exercici :ref:`exercici_meitatnum` a ``02_08_meitatnum/`` i, dins del
fitxer ``meitatnum.py`` realitza les transformacions que hem vist en aquesta
secció.

Pots fer servir els següents *doctest*:

.. code-block:: python

    >>> meitat_num(4)
    'La meitat de 4 és 2.0'
    >>> meitat_num(5)
    'La meitat de 5 és 2.5'

Exercici 9. L'edat aproximada de l'usuari (re-loaded)
=====================================================

Copia l'exercici :ref:`exercici_edataproximada` a ``02_09_edataproximada/`` i
realitza l'extracció del codi dins la funció ``edat_aproximada()`` tal i com hem
vist en aquesta secció.

Construeix-te el *doctest* a partir de la simulació del programa original.


Exercici 10. Una calculadora bàsica (re-loaded)
===============================================

Copia l'exercici :ref:`exercici_calculadorabasica_python` a
``02_10_calculadorabasica/`` i extreu el codi del càlcul i composició de la
sortida a la funció ``calculadora_basica()``.

En aquesta ocasió has de tenir en comptes que:

* la funció ha de rebre dos números que hauràs de separar amb comes

* el text a retornar molt probablement correspon al que abans escrivies amb més
  d'un ``print()``.

  Com que ara has de retornar un sol valor, et toca modificar lleugerament el
  codi antic de manera que els quatre resultats apareguin concatenats en una
  sola variable de text.

  Una pista:

  .. code-block:: python

        >>> text = 'hola' + '\n' + 'adéu'
        >>> text
        'hola\nadéu'
        >>> print(text)
        hola
        adéu

   Així, el *doctest* serà:

   .. code-block:: python

        >>> calculadora_basica(6, 2)
        '6 + 2 = 8\n6 - 2 = 4\n6 * 2 = 12\n6 / 2 = 3.0\n'


Exercici 11. Si ets adult llavors ets responsable (re-loaded)
=============================================================

En aquesta ocasió convertirem un exercici amb condicionals. Cap problema.

Copia l'exercici :ref:`exercici_preso` a ``02_11_preso/`` i realitza els canvis
d'extracció que estem treballant.

Afegeix, com a mínim, **tres** *doctest*: els dos de la simulació i un tercer
amb el valor ``18``.


Exercici 12. Dos en ordre (re-loaded)
=====================================

Converteix l'exercici :ref:`exercici_dosenordre` dins ``02_12_dosenordre/``.

Assegura't que el doctest inclou les dues possibilitats: que el primer sigui
menor que el segon i que el segon sigui menor que el primer.

Exercici 13. Mesos i anys (re-loaded)
=====================================

Converteix l'exercici :ref:`exercici_mesosianys` dins ``02_13_mesosianys/``.

Assegura't que els *doctest* inclouen els casos de gener, decembre i un altre.

Exercici 14. Tres en ordre (re-loaded)
======================================

Converteix l'exercici :ref:`exercici_tresenordre` dins ``02_14_tresenordre/``.

Assegura't que inclous **sis** *doctest* amb totes les possibiltats.

