##########
Composició
##########

Definició: Es diu que una classe A es *composa* d'una altra B quan
existeix una dependència de A a B com a l'agregació, però en aquest
cas, la instància de B està completament lligada a la de A. Es diu
també B forma part de A i que A té (has-a) B.

Aquesta relació de dependència es coneix com **composició**. En java,
la implementació és molt similar a la de la relació d'agregació: amb
una propietat. La diferència consisteix en el fet que la creació de la
instància (on es fa el new) és dins de la classe A. En cas que
haguéssim de duplicar una instància de la classe A, hauríem també de
duplicar la instància de la classe B.

.. _relacions_exercicis_ullsdegat:

Exercici 2. Els ulls del gat Renat
==================================

En aquest exercici implementarem la classe UllDeGat. 

Un UllDeGat pot estar obert o tancat i
ofereix els mètodes:

* ``String obret()``
* ``String tancat()``
* ``boolean estasObert()``

En obrir-se els ulls retorna "nyeek" i en tancar-se retorna "plonx". 
En cas que demanem obrir un ull que ja està obert, retornarà la cadena buida (no null!). El mateix
passa quan demanem que es tanqui un ull ja tancat.

Els ulls de gat comencen tancats, a menys que s'indiqui el contrari al constructor. Això implica que
oferirà dos constructors, el de per defecte i un d'específic que rebrà com a argument un booleà
indicant si els ulls han de començar oberts.

Amplia la classe GatRenat de :ref:`relacions_exercicis_picarol` de manera que ara tingui **dos**
ulls. Els ulls estaran oberts o tancats depenent de l'estat del gat. Si el gat està dret, tots dos
ulls estaran oberts. Si està assegut, l'ull dret estarà obert i l'esquerre estarà tancat. Quan està
estirat, tots dos ulls estaran tancats.

La nova versió de GatRenat oferirà els següents nous mètodes:

* ``UllDeGat getUllDret()``: retorna una còpia de l'ull dret
* ``UllDeGat getUllEsquerre()``: retorna una còpia de l'ull esquerre

.. note:: Aquest exercici disposa d'un test de prova que pots descarregar-te :download:`d'aquí
   <_recursos/E005002TestSuite.tar.gz>`.

   En aquest cas, hauràs d'executar és ``E005002TestSuite.java``.

   Desempaqueta el contingut del fitxer a la carpeta on hi col·locaràs el teu codi de la manera
   habitual.



Tot plegat
==========

Respecte les dues relacions que acabem de veure, considerarem que:

* la relació d'agregació es un tipus de relació feble entre dues
  classes.

  Presenta les següents característiques:

  - el component pot ser accedit directament sense que calgui passar
    per la instància que l'agrega.

  - el component pot sobreviure la instància que l'agrega.

  - el mateix component podria ser agregat per més d'una instància

  - la instància que agrega el component normalment no té
    responsabilitats sobre aquest: per exemple, no sol ser
    l'encarregada de crear-lo.

* la relació de composició és molt més forta que la d'agregació.

  Algunes característiques:

  - la instància que conté el component, es considera *propietària*
    d'aquest.

  - els component són elements (part) del propietari.

  - el component forma part de l'estat del propietari. És a dir, un
    canvi en l'estat del component resulta en un canvi d'estat del
    composat.

  - el component només pot ser accedit a partir del contenidor. Es diu
    que el component està encapsulat pel propietari. Sovint, la classe
    contenidora no ofereix mecanismes per obtenir el component (get),
    especialment quan aquest sigui mutable.

  - el temps de vida del component queda liminat al del propietari. És
    a dir, quan desaparegui la instància del propietari, també ho farà
    la del component.

  - el propietari és responsable dels seus components: per exemple, el
    crea.

Exercici 3. ☼ La llista dinàmica en Java
========================================

**Atencio**: Aquest és un exercici d'ampliació. Encara que opcional, et pot resultar molt
aclaridor si no has treballat mai amb memòria dinàmica de manera explícita.

Implementa en Java la llista dinàmica vista a la secció :ref:`constructors_i_destructors` de la
secció :doc:`constructors_i`.

Et caldran tres classes:

#. Node: tindrà dos propietats: *valor* que per simplificar serà un
   string, i *seguent* que serà de tipus Node (sí, com la classe!) i
   que per defecte valdrà null.

   La classe oferirà la possibilitat d'accedir a les dues propietats
   (get/set) i inicialitzar-les totes dues, una o cap, en el moment de
   la seva construcció.

#. Llista: tindrà una propietat: *primer* de tipus Node que
   inicialment apuntarà a null.

   Oferirà els mètodes:

   * ``void afegir(int, String)``: afegeix un nou node a la posició de
     la llista indicada pel primer paràmetre i el valor expressat pel
     segon. En cas que la posició especificada sigui més gran que el
     nombre d'elements a la llista, simplement es col·locarà el nou
     element al final. Altrament, es desplaçaran convenientment tots
     els nodes de la llista per fer encabir el nou a la posició
     requerida.

   * ``void eliminar(int)``: elimina el node situat a la posició
     indicada pel paràmetre. Si la posició és superior al nombre
     d'elements de la llista, no fa res.

   * ``void elimina(String)``: elimina tots els nodes que el valor
     coincideixi amb el del paràmetre. Si no hi ha cap, no fa res.

   * ``String toString()``: retorna una representació de la llista en
     forma de String. Així, si la llista conté els valors "Hola", "i",
     "adéu", aquest mètode retornarà el String "[Hola -> i -> adéu]". Si
     està buida, retornarà simplement "[]"

#. UsaLlista: disposarà d'un ``main()`` que construirà una llista,
   afegirà els valors "Hola", "i", adéu", i després els eliminarà un a
   un començant pel primer. A cada pas, mostrarà el contingut de la
   llista per sortida estàndard. El resultat hauria de ser quelcom
   molt similar a:

   .. code-block:: none

        []
        [Hola]
        [Hola -> i]
        [Hola -> i -> adéu]
        [i -> adéu]
        [adéu]
        []

Exercici 4. ☼ Les Urpes del gat Renat
=====================================

Et proposo aquest exercici d'ampliació dels conceptes que hem
treballat en aquest tema.

Atenció: aquest problema és un **repte**. La part més difícil és, com
sol passar, entendre el que es demana. Ah! Encara que ho sembli, no et
caldrà multifil (*multithread*).

Implementa la classe UrpesDeGat i modifica GatRenat segons el diagrama
de classes:

El funcionament de UrpesDeGat és el següent:

1. Inicialment les urpes estan esmolades al 100% i s'estan desgastant

2. Quan criden el servei esmola(), les urpes comencen a esmolar-se. El
   màxim, és clar, és un 100%.

3. Quan criden el servei desgasta(), les urpes comencen a
   desgastar-se. El mínim, és clar, és un 0%

4. Quan es demana el canvi a esmolant o desgastant, o bé quan es
   demana el grau d'esmolat es recalcula el grau d'esmolament a partir
   del temps que portava esmolant-se o desgastant-se des del darrer
   recàlcul, i per cada 1 milisegon se li suma/resta un 1%
   d'esmolament.

El gat Renat tindrà urpes, és clar. I fixa't que ara el gat Renat
tindrà un nou estat possible (caminant). Quan el gat estigui en un
estat que no sigui caminant, les seves urpes estaran desgastant-se i,
quan estigui caminant, en canvi, les urpes estaran esmolant-se. En cas
que les urpes estiguin totalment desgastades, el gat Renat deixarà de
fer-nos cas a les ordres de canvi d'estat i es posarà a caminar fins
que el grau d'esmolament sigui al menys 20%.

Prova la nova versió del gat Renat amb el seu entorn operatiu, tot
realitzant els canvis que consideris oportuns per a mostrar les noves
funcionalitats.

Com a pista/ajut per a treballar aquest exercici, considera el següent
codi:

.. code-block:: java
    :linenos:

    /* Demostració d'ús del temps */
    import java.util.Calendar;

    public class GatRenat {
        private int vides = 9;
        private long momentNaixement;
        public GatRenat() {
            // ens guardem el moment del naixement
            momentNaixement = java.util.Calendar.getInstance().getTimeInMillis();
            // ens esperem una estoneta perquè es pensin que costa molt crear un gat
            esperatUnaEstona();
        }
        private static void esperatUnaEstona() {
            // fa que el programa es detengui una estona pseudoaleatòria
            // De moment, no cal que intentis entendre com ho fa això
            try {
                long tempsEspera = (long)(Math.random() * 1000);
                java.lang.Thread.sleep(tempsEspera);
            } catch (InterruptedException e) {}
        }
        public int getVides() { return vides; }
        public void setVides(int vides) { if (vides>=0) this.vides = vides; }
        public long getTempsViu() {
            // retorna el nombre de milisegons que porta viu
            long actual = java.util.Calendar.getInstance().getTimeInMillis();
            return actual - momentNaixement;
        }
        public String toString() {
            return "Gat Renat amb " + vides + " vides.  Porta viu " + getTempsViu() + " milisegons";
        }
        public static void main(String[] args) {
            // crea uns quants GatRenat per demostrar com passa el temps
            GatRenat[] gats = new GatRenat[10];
            for (int i=0; i < gats.length; i++) {
                gats[i] = new GatRenat();
                gats[i].setVides(i);
                System.out.println(gats[i]);
            }
            // tornem a veure el temps que porten vius
            System.out.println("I si tornem mirar:");
            for (int i=0; i < gats.length; i++) {
                System.out.println(gats[i]);
            }
        }
    }

----

*Ref. 20.1.4.2*

