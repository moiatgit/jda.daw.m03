######
Arrays
######

Per Java un *array* és un contenidor d'un nombre fix d'elements d'un
mateix tipus disposats en ordre.

A l'hora de declarar un array, no ens cal saber quants elements tindrà,
però sí de quin tipus seran.

.. code-block:: java

    int[] notesCurs;

Amb això, el compilador sap que ``notesCurs`` és una referència a una seqüència
de valors enters. De moment, però, no s'ha reservat espai per cap element.

Suposant que un curs té quatre notes (quatre avaluacions), la
inicialització es realitza de la següent manera:

.. code-block:: java

    notesCurs = new int[4];

Ara tenim un array inicialitzat. Això vol dir que hi ha espai reservat per
enmagatzemar el valor dels quatre enters.  Encara, però, no tenim valors
a aquests espais. Ens caldrà assignar-los un valor abans de poder fer res
amb ells.

Els arrays en java s'indexen amb un valor enter, començant pel 0. Així,
una manera d'inicialitzar les nostres notes serà:

.. code-block:: java

    notesCurs[0] = 8;
    notesCurs[1] = 9;
    notesCurs[2] = 10;
    notesCurs[3] = 10;

Veiem que els arrays de Java són mutables com el ``list`` de Python. 

Java ens ofereix una manera d'inicialitzar els valors més compacta. En l'exemple:

.. code-block:: java

    int[] notesCurs = { 8, 9, 10, 10 };

Fixa't que en aquest cas, el compilador ja es preocupa de comptar quants enters necessitem.

Podrem mostrar els valors resultants, per exemple:

.. code-block:: java

    System.out.println("La nota de la primera avaluació és " + notesCurs[0]);
    System.out.println("La nota de la segona avaluació és " + notesCurs[1]);
    System.out.println("La nota de la tercera avaluació és " + notesCurs[2]);
    System.out.println("La nota de la quarta avaluació és " + notesCurs[3]);

Per suposat, els arrays permeten l'automatització d'aquest tipus de
tasques repetitives, fent servir bucles. Per exemple:

.. code-block:: java

    for(int i=0;i<notesCurs.length;++i) {
        System.out.println("La nota de la quarta avaluació és " + notesCurs[i]);
    }

Fixa't que ``notesCurs.length`` ens retorna la longitud de l'array però, a
diferència del ``length()`` dels strings, aquí no porta parèntesis!


.. _exercici_notes_en_maco_java:

Exercici 24. ☞ Notes en maco en Java
====================================

Rescata l'exercici :ref:`Notes en maco <exercici_notes_en_maco_python>` i
desenvolupa una funció anomenada ``String sequenciaMaca(int[])`` que faci el
mateix en Java.

La funció estarà dins una classe (i fitxer) anomenada ``NotesUtils`` que
no cal que contingui cap ``main()``.

Exercici 25. ☞ Conversor de string a array de caràcters
=======================================================

Desenvolupa una funció que converteixi un string a una seqüència de caràcters.

La signatura de la funció és ``char[] stringToArray(String)`` i dues simulacions
d'execució podrien ser:

.. code-block:: bash

    jshell> StringUtils.stringToArray("hola");
    $2 ==> char[4] { 'h', 'o', 'l', 'a' }

    jshell> StringUtils.stringToArray("");
    $3 ==> char[0] {  }


Exercici 26. ☞ Conversor d'array de caràcters a string
======================================================

Desenvolupa una funció que converteixi una seqüència de caracters a string.

La signatura de la funció és ``String arrayToString(char[])`` i una simulació

.. code-block:: bash

    jshell> StringUtils.arrayToString( new char[] { 'h', 'o', 'l', 'a' });
    $2 ==> "hola"

Exercici 27. ☼ Ampliar un array
===============================

Desenvolupa una funció que rebi com a paràmetres un array d'enters i un enter i
retorni un nou array que contingui els mateixos elements de l'array d'entrada
més l'enter addicional.

La signatura serà ``int[] afegeixEnterAArray(int, int[])``

.. code-block:: bash

    jshell> AfegeixEnterAArray.afegeixEnterAArray( 5, new int[] { 1, 2, 3, 4 });
    $2 ==> int[4] { 1, 2, 3, 4, 5 }

Exercici 28. ☼ Afegir a un array si no hi és
============================================

Desenvolupa una funció que rebi un enter i un array com a paràmetre, i retorni
un nou array amb el contingut de l'array d'entrada, més el nou element si no hi
era.

Considera la següent interacció:

.. code-block:: bash
    :linenos:

    jshell> int[] antics = new int[] {1, 2, 3, 4};
    antics ==> int[4] { 1, 2, 3, 4 }

    jshell> AfegeixSiNoHiEs.afegeixSiNoHiEs(5, new int[] {1, 2, 3, 4});
    $3 ==> int[5] { 1, 2, 3, 4, 5 }

    jshell> int[] nous = AfegeixSiNoHiEs.afegeixSiNoHiEs(3, antics);
    nous ==> int[4] { 1, 2, 3, 4 }

    jshell> nous[3] = 1000;
    $5 ==> 1000

    jshell> nous
    nous ==> int[4] { 1, 2, 3, 1000 }

    jshell> antics
    antics ==> int[4] { 1, 2, 3, 4 }

Fixa't que la línia 10 modifica el valor d'una de les posicions del nou array
però que a la línia 16 es veu que l'antic array no ha quedat modificat.

Exercici 29. ☼ Manteniment de notes
===================================

En aquesta ocasió farem una versió en Java del programa de :ref:`manteniment de
notes <exercici_manteniment_notes_python>` que vam fer en Python.

Exercici 30. ☼ Manteniment de notes ampliat
===========================================

Afegeix al manteniment de notes anterior, les opcions ``màxima``, ``mínima``,
``quantes`` i ``cerca n`` dels exercicis posteriors a :ref:`manteniment de notes
<exercici_manteniment_notes_python>`


.. _exercici_modificacio_notes_java:

Exercici 31. ☼ Modificació de notes
===================================

Amplia el manteniment de notes amb la comanda ``modifica pos val`` que permet
modificar el valor de la posició ``pos`` per ``val``.

Així, la següent interacció funcionaria:

.. code-block:: bash

    > mostra
    5, 4, 3, 6 i 9
    > modifica 1 10
    fet
    > mostra
    10, 4, 3, 6 i 9
    > modifica 6 10
    no tinc tantes notes
    > modifica 0 10
    Començo a comptar per 1
    > modifica x 10
    La posició ha de ser un enter positiu major que 0
    > modifica 30 x
    El valor ha de ser un enter positiu

